
## 11장 테스팅


일반적으로 다음과 같은 테스트 케이스들을 생각해봐야한다.

## 1단계 : 테스트 케이스 정의
### - 정상적인 케이스
> 일반적인 입력에 대해서 정확한 출력을 해내는가?? 

### - 극단적인 케이스
> 비어있는 배열, 가장 작은 배열, 큰 크기의 배열을 넘긴다면 어떻게 되는가?

### - 널(null)입력 , 잘못된(illegal)
> 입력이 잘못 주어졌을 때 코드가 어떻게 동작하는지 고려 필요,

### - 특수한 입력
> 특수한 패턴의 입력도 주어질 수 있다. 예를들면 이미 정렬된 데이터가 주어진다면?, 아예 역순으로 정렬된 배열이 주어진다면과 같은 데이터이다.


---

## 2단계 : 예상되는 결과를 정리하라

정렬 메서드인 sort에서 정렬된 결과를 새로운 배열로 복사한뒤 반환한다면, 기존 배열의 내용은 변경되지 않아야 한다는 조건들이 있다면 해당
조건이 만족되었는지도 확인할 수 있다.

---

## 3단계 : 테스트 코드를 작성하라.

테스트 케이스를 만들고 결과를 정의했다면 테스트 케이스를 코드 형태로 구현하는것은 간단하다.
테스트 결과에 대해서 다양한 코드들을 만들 수 있다.

---


## ㅁ 문제 해결에 관한 문제

면접에서 이미 있는 장애에 대해서 어떻게 디버깅하고 해결할 것인지를 설명하라는 문제도 제출이 된다.
다양한 사례가 있겠지만 다음의 순서로 진행해보면 좋을듯 하다.

1. 시나리오를 이해한다
2. 문제를 쪼개라
3. 구체적이고 관리 가능한 테스트를 생성해라.


---


## 13장 자바

### 오버로딩 vs 오버라이딩

 - 오버로딩 
> 메서드가 같은 이름을 갖고 있으나 인자의 갯수나 타입이 다른 경우를 말한다.
> ```java
> public void sample() { ...}
> public void sample(String name) { ...}
> public void sample(int age) { ...}
> ```

 - 오버라이딩
> 상위 클래스의 메서드를 자식 클래스에서 재정의 하는것을 의미한다.
> ```java
> public abstract Parent{
>   public abstract int total(int a , int b);
> }
> 
> public void SumChild extend Parent {
>   public int total() {
>     return a + b;
>   }
> }
> 
> public void MinusChild extend Parent {
>   public int total() {
>     return a - b;
>   }
> }
> ```

---

### 컬렉션 프레임워크
> 자바의 컬렉션 프레임워크는 가장 많이쓰기도 하고 유용하다.

#### ArrayList
> ArrayList는 동적으로 크기가 조절되는 배열이며, 새 원소를 삽입하면 크기가 늘어난다.

#### Vector
> Vector는 ArrayList와 비슷하지만 동기화 되어있다는 차이가 있다.

#### LinkedList
> 자바에서 제공하는 클래스이며, 자주 사용하지는 않는다.

#### HashMap
> HashMap 컬렉션은 면접이나, 실무에서 가장 광범위하게 사용된다
> ```java
> HashMap map = new HashMap();
> map.put("one", "one");
> map.put("two", "two");
> System.out.println(map.get("one"));
> ```


---

### 데이터 베이스


#### 명시적 JOIN과 묵시적 JOIN


명시적 JOIN | 묵시적 JOIN
----------|----------
SELECT cName, tName <br> FROM C INNER JOIN T <br> ON C.id = T.id| SELECT cName, tName <br> FROM C, T <br> WHERE C.id = T.id

---

#### 비정규화 vs 정규화 데이터베이스

`정규화 데이터베이스`란 중복을 최소화하도록 설계된 데이터베이스를 의미한다. 
`비정규화 데이터베이스`란 읽는 시간을 최적화 하도록 설계된 데이터베이스를 의미한다.

정규화된 데이터베이스의 경우 데이터의 중복이 적어 데이터베이스에 한번만 저장해도 된다는 장점이 있으며, 비정규화 데이터베이스의 경우
데이터를 중복해서 저장하여 높은 규모 확장ㅅ헝을 실현하기 위해 자주사용 되는 기법이다. 
단순히 정규화된 데이터베이스가 좋다기보다는 상황에 따라 다른듯하다(개인적인 생각).

---

### 소규모 데이터베이스 설계

#### 1단계 모호성 처리
> 데이터베이스에 관계된 문제에는 의도적이든 의도적이지 않던 모호한 부분이 내포되어있다.
> 따라서 설계를 시작하기 전에 정확히 무엇을 설계해야하는지에 대해서 이해해야 한다.


#### 2단계 핵심 객체 정리.
> 만들고자 하는 시스템의 핵심 객체가 무엇인지 살펴봐야 한다. 보통 핵심 객체 하나당 하나의 테이블을 사용한다.

#### 3단계 관계 분석
> 핵심 객체 테이블의 설계를 하고 나면 다른 테이블과 어떠한 관계가 있는지 확인해야한다. 다대다, 일대다, 다대일 등등을 미리 생각하여
> 연관관계를 구현해야한다.

#### 4단계 행위 조사
> 마지막으로 세부적인 부분을 채워넣어야 한다. 흔하게 수행될 작업들을 살펴보고, 관련된 데이터들을
> 어떻게 저장하고 가져올 것인지 이해해야 한다.

---

### 대규모 데이터베이스 설계
> 대규모의 규모 확장성이 높은 데이터베이스를 설계하기 위해서는 JOIN 연산은 일반적으로 아주 느리다고 간주해야 한다.
> 따라서 데이터를 비정규화 해야 한다. 데이터를 여러 테이블에 중복해서 저장해야 할지도 모르니 데이터가 어떻게 사용될지는 유심히 생각해야 한다.

---

### 스레드와 락

#### 자바의 스레드

> 자바의 모든스레디는 java.lang.Thread 클래스 객체에 의해 성성되고 제어된다. 우리가 흔히 사용하는 main() 메서드를 실행하면 자동으로 하나의 스레드가 만들어지는데 이를 주 스레드라고 한다.
> <br> 자바에서 스레드의 구현방식은 두가지가 있다.

- java.lang.Runnable 인터페이스를 구현
- java.lang.Thread 클래스를 상속


#### Runnable 인터페이스를 구현하는 방법
```java
public interface Runnable() {
   void run();
}
```

Runnable interface는 다음과 같이 구조가 간단하다.
Runnable을 사용하기 위해서는 다음 과정을 거쳐 class 를 만든다.

1. Runnable 클래스를 구현하는 클래스를 만든다.
2. Thread타입의 객체를 만들때 Thread의 생성자에 Runnable 객체를 인자로넘긴다.
3. 이전 단계에서 생성한 Thread 객체의 start()메서드를 호출한다.


#### Thread 클래스 상속
> Thread 방식은 말그대로 Thread 클래스를 상속받아 run() 메서드를 오버라이딩해야 하며, 생성자는 상위 클래스의 생성자를 명시적으로 호출해야한다.


Thread 클래스 상속을 통해 구현하는 방법또한 Runnable 사용과 아주 비슷하나, 인터페이스를 구현하는 대신 Thread를상속받았고, 자체적으로 start를 직접 호출한다.


#### Runnable vs Thread 상속
> 1. Java 에서는 다중 상속(multiple inheritance)를 지원하지 않는다. 짜라서 Thread 클래스를 상속하게 되면 하위 클래스는 다른 클래스를 상속할 수 없다. 따라서 Runnable interface를 구현하면 쓰레드와 함께 다른 클래스를 상속받을 수 있다.
> 2. Thread클래스의 모든 것을 상속받는 것이 너무 부담되는 경우에는 Runnable을 구현하는 편이 나을지도 모른다.

---

### 동기화와 락

> 어떤 프로세스 안에서 생성된 스레드들은 메모리 공간을 공유한다, 이러한 점이 좋을때도, 나쁠때도 있다. 스레드가 서로 데이터를 공유할 수 있다는점은 장점
> 이기도 하지만, 같은 자원을 동시에 변경하는 경우에는 문제가 된다. 자바는 이러한 문제를 해결하기 위해 동기화 (synchronization) 을 제공한다.


`synchronized` 와 `Lock` 키워드는 동기화 구현을 위한 기본이 된다.

#### 동기화 
`synchronized` 키워드를 사용할때는 공유 자원에 대한 접근을 제어한다. 해당 키워드는 메서드에 적용할 수도 있고, 특정한 코드 블록에
적용할 수도 있다. 해당 키워드는 같은 객체를 동시에 실행하는 것 또한 방지해준다.

예제로 작성하지 않았으나, 같은 객체를 가리키고 있지 않다면 동시호출이 가능하다.



#### 락
조금 더 세밀하게 동기화를 제어하고 싶을때는 락(lock)을 사용한다. `Lock`을 공유 자원에 붙이면 해당 자원에 대한 접근을 동기화 할 수 있다.

스레드가 해당 자원을 접근하려고 하면 우선 그 자원에 붙어있는 `Lock`을 획득해야한다. 특정 시점에 해당 `Lock`을 가지고 있는스레드는 하나뿐이다, 따라서 해당 공유자원은
한번에 한 쓰레드만이 사용할 수 있다.

```java

Lock lock = new ReentrantLock();

public int sample() {
   
   lock.lock();
        ...
   lock.unlock();   
}
```
lock(), unlock() 메서드를 활용하여 작성할 수 있다.

---

#### 교착상태와 교착상태 방지

> ### 교착상태 <br>
> 교착 상태란 첫 번째 스레드는 두 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있고, 두 번째 스레드 역시 첫 번째 스레드가 사용중인 객체의 락이 필리기를 기다리고 있는 상황을 말한다.
> 모든 스레드가 해당 락이 풀리기를 기다리고있기 때문에, 무한 대기 상태에 빠지게 된다. 이런 상태를 교착상태라고 한다.

교착 상태는 다음과 같은 4가지 조건이 충족되면 발생한다.
 - 상호 배제(mutual exclusion) : 한 번에 한 프로세스만 공유 자원을 사용할 수 있다. (정확하게 이야기하면 공유 자원에 대한 접근 권한이 제한된다.). 자원의 양이 제한되어 있더라도 교착 상태는 발생할 수 있다.
 - 들고 기다리기 (hold and wait) : 공유 자원에 대한 접근 권한을 갖고 있는 프로세스가, 그 접근 권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다.
 - 선취(preemption) 불가능 : 한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다.
 - 대기 상태의 사이클 : 두개 이상의 프로세스가 자원 접근을 기다리는데 그 관계에 사이클이 존재한다.

교착 상태를 해결하기 위해서는 위에있는 4개의 조건중 하나를 제거하면 된다.
하지만 이들 조건 가운데 상당수는 만족되기 어려운 것이라서 까다롭다. 대부분 교착 상태 방지 알고리즘은 4번조건, 즉 대기상태의사이클이 발생하는 일을 막는 데 초점이 맞춰져 있다.


