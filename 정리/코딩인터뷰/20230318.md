
## 11장 테스팅


일반적으로 다음과 같은 테스트 케이스들을 생각해봐야한다.

## 1단계 : 테스트 케이스 정의
### - 정상적인 케이스
> 일반적인 입력에 대해서 정확한 출력을 해내는가?? 

### - 극단적인 케이스
> 비어있는 배열, 가장 작은 배열, 큰 크기의 배열을 넘긴다면 어떻게 되는가?

### - 널(null)입력 , 잘못된(illegal)
> 입력이 잘못 주어졌을 때 코드가 어떻게 동작하는지 고려 필요,

### - 특수한 입력
> 특수한 패턴의 입력도 주어질 수 있다. 예를들면 이미 정렬된 데이터가 주어진다면?, 아예 역순으로 정렬된 배열이 주어진다면과 같은 데이터이다.


---

## 2단계 : 예상되는 결과를 정리하라

정렬 메서드인 sort에서 정렬된 결과를 새로운 배열로 복사한뒤 반환한다면, 기존 배열의 내용은 변경되지 않아야 한다는 조건들이 있다면 해당
조건이 만족되었는지도 확인할 수 있다.

---

## 3단계 : 테스트 코드를 작성하라.

테스트 케이스를 만들고 결과를 정의했다면 테스트 케이스를 코드 형태로 구현하는것은 간단하다.
테스트 결과에 대해서 다양한 코드들을 만들 수 있다.

---


## ㅁ 문제 해결에 관한 문제

면접에서 이미 있는 장애에 대해서 어떻게 디버깅하고 해결할 것인지를 설명하라는 문제도 제출이 된다.
다양한 사례가 있겠지만 다음의 순서로 진행해보면 좋을듯 하다.

1. 시나리오를 이해한다
2. 문제를 쪼개라
3. 구체적이고 관리 가능한 테스트를 생성해라.


---


## 13장 자바

### 오버로딩 vs 오버라이딩

 - 오버로딩 
> 메서드가 같은 이름을 갖고 있으나 인자의 갯수나 타입이 다른 경우를 말한다.
> ```java
> public void sample() { ...}
> public void sample(String name) { ...}
> public void sample(int age) { ...}
> ```

 - 오버라이딩
> 상위 클래스의 메서드를 자식 클래스에서 재정의 하는것을 의미한다.
> ```java
> public abstract Parent{
>   public abstract int total(int a , int b);
> }
> 
> public void SumChild extend Parent {
>   public int total() {
>     return a + b;
>   }
> }
> 
> public void MinusChild extend Parent {
>   public int total() {
>     return a - b;
>   }
> }
> ```

---

### 컬렉션 프레임워크
> 자바의 컬렉션 프레임워크는 가장 많이쓰기도 하고 유용하다.

#### ArrayList
> ArrayList는 동적으로 크기가 조절되는 배열이며, 새 원소를 삽입하면 크기가 늘어난다.

#### Vector
> Vector는 ArrayList와 비슷하지만 동기화 되어있다는 차이가 있다.

#### LinkedList
> 자바에서 제공하는 클래스이며, 자주 사용하지는 않는다.

#### HashMap
> HashMap 컬렉션은 면접이나, 실무에서 가장 광범위하게 사용된다
> ```java
> HashMap map = new HashMap();
> map.put("one", "one");
> map.put("two", "two");
> System.out.println(map.get("one"));
> ```
> 