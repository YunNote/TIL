# 클라이언트 식별과 쿠키

> 해당 내용에서는 서버가 통신하는 대상을 식별하는데 사용하는 기술에 대해 본다.

---

## 개별 접촉

HTTP는 익명으로 사용하며 상태가 없고, 요청과 응답으로 통신하는 프로토콜이다. 따라서 요청을 처리하고나서 응답을 
클라이언트로 전송하게 된다. 

서버는 요청을 보낸 사용자에 대해서 식별하기 위해 약간의정보를 이용할 수 있다.

1. 개별인사 : 사용자에게 특화된 메시지나 페이지 내용을 만든다.
2. 사용자 맞춤 추천 : 사용자가 좋아할만한 내용에 대한 컨텐츠를 추천한다. 특정 이벤트에 대한 컨텐츠를 제시할수도 있다.
3. 저장된 사용자 정보 : 복잡한 주소라던지, 특정한 정보들을 매번 기입하는것은 사용자들이 싫어한다. 따라서 사용자가 편하게 사용 할 수 있게끔 저장된 사용자 정보를 사용한다.

4. 세션 추적 : HTTP트랜잭션은 상태가 없다. 많은 웹사이트에서는 사용자가 사이트와 상호작용할 수 있도록 사용자의 상태를 남긴다. 이러한 상태를 유지하기 위해서는 사용자에게서 오는 HTTP트랜잭션에 대해서 식별할 방법이 필요하다.

---


## HTTP 헤더 

사용자에 대한 정보를 전달하는 HTTP헤더는 대략적으로 다음과 같다

`From` - 요청 타입이며 사용자의 이메일 주소를 의미한다.<br>
> From 의 경우 사용자의 이메일을 각각 다르게 가지고있는것이 이상적이지만, 악의적으로 이메일을 모아서 스팸을 발송하는 문제가있어
> 헤더를 보내는 브라우저는 많지 않다. 다만 크롤링봇이나 데이터를 수집하는 봇들은 본의아니게 문제를 발생시킬 수 있어 웹사이트에게 From 헤더를 통해 연락가능한 이메일을 제공한다.

<br>

`User-Agent` - 요청 타입이며 사용자의 브라우저 정보를 담고 있다. <br>
> 사용자가 사용하고있는 브라우저의 이름과 버전 정보, 어떤 경우에는 운영체제에 대한 정보까지 서버에게 알려준다.

<br>

`Referer` - 요청 타입이며, 사용자가 현재 링크를 타고온 근원 페이지를 의미한다 <br>
> 사용자가 현재 페이지로 유입하게 한 웹페이지의 URL을 가리킨다. 해당 헤더만으로 사용자를 식별할 수는 없지만
> 사용자가 이전에 어떠한 페이지를 방문하였는지 알려준다.

`Authorization` - 요청 타입이며 사용자의 이름과 비밀번호를 의미 <br>
`Client-ip` - 확장(요청) 타입이며, 클라이언트의 IP주소 <br>
`X-Forwarded-For` - 확장(요청) 타입이며, 클라이언트의 IP주소 <br>
`Cookie` - 확장(요청) 타입이며, 서버가 생성한 ID정보  <br>

---

## 클라이언트 IP 주소 

초기 웹에서는 식별에 클라이언트 IP주소를 사용하고자 하였다. 해당 방식은 사용자의 확실한 IP주소를 가지고 있고, 좀처럼 혹은 아예 변경되지 않기 때문에
요청마다 클라이언트의 IP를 알 수 있따면 문제 없이 동작한다.
(IP는 서버에서 TCP케넥션의 Ip주소를 알아낼 수 있다.)

다만 해당 방식은 다음과 같은 약점을 가지고 있다.

- 클라이언트 IP주소는 사용자가 아닌 해당 컴퓨터를 가리키기 때문에 여러 사용자가 해당 컴퓨터를 공용으로 사용하게 된다면 특정 사용자를 식별할 수 없다.
- 인터넷 서비스 제공자는 사용자가 로그인하면 동적IP를 할당한다 따라서 매번 다른 주소를 받기 때문에 사용자라를 IP주소로 식별할 수 없다.
- 보안을 강화하고 부족한 주소를 관리하기위해 NAT 방화벽을 통해 인터넷을 사용한다. 해당 NAT방식은 실제 IP주소를 방화벽 뒤로 숨기고 실제 IP주소를 내부에서 사용하는 하나의 방화벽 IP주소로 변환하기 때문에 식별하기 힘들다.
- 보통 HTTP 프록시와 게이트웨이는 원 서버에 새로운 TCP연결을 한다. 따라서 웹서버에서는 실제 클라이언트의 IP가 아닌 프록시 또는 게이트웨이의 IP주소를 바라본다. 일부 프록시는 IP주소를 보존하기위해 확장 헤더를 추가하여 해당 문제를해결하려고 하였다. 다만 모든 프록시가 지원하지는 않는다.

---

## 사용자 로그인 
 
위에나온 클라이언트 IP보다 사용자의 접속 정보로 명시적으로 식별요청을 할 수도 있다.

HTTP에서는 로그인이 더 쉽도록 Authorization헤더를 사용하여 해당 사용자의 정보를 전달하는 자체적인 체계를 가지고 있다.

한번 로그인하게되면 그다음 요청에 대해서 로그인 정보를 함께 보내기 때문에 서버에서는 사용자를 항상 확읺가능하며, 사이트에 접근하기전
로그인이 되어있지 않다면 로그인 페이지로 이동하라고 응답 코드를 내릴 수 있다.

---

## 뚱뚱한 URL

어떤 웹사이트들은 URL의 경로의 처음 또는 끝에 사용자의 상태정보를 포함도록 하였고 이를 뚱뚱한 URL 이라고 한다.
거의 모든 URL에 해당 상타에 대한 문자열을 담도 다녔다. 하지만 해당 기술에는 여러 문제가 있다.

1.못생긴 URL
> URL이 너무 복자뱋져 사용자들에게 혼란을 줄 수 있다.

2. 공유하지 못하는 URL
> URl에 사용자에 대한 상태정보가 포함되다 보니 해당 URL을 다른사람이 알게된다면 본의아니게 개인 정보를 공유하게 된다.

3. 서버 부하 증가
> 서버는 뚱뚱한 URL에 해당하는 HTML페이지를 다시 그려야 한다. 

4. 이탈 
> URL을 의도지 않게 사용하여 URL 세션에서 이탈 하기 쉽다. 

5. 세션 간 지속성으 ㅣ부재
> 사용자가 URL을 북마킹 하지 않는 이상 로그아웃을 하면 모든 정보를 잃는다.

---

## 쿠키 
> 쿠키는 사용자를 식별하고 세션을 유지하는 방식중 가장 널리 사용되는 방식중 하나이다.

### 쿠키의 타입

- 세션쿠키
  #### 세션쿠키는 사이트를 탐색할때 관련한 설정과 선호 사항들을 임시로 저장하는 쿠키다. 세션 쿠키는 브라우저를 닫으면 삭제된다.


 - 지속 쿠키
    #### 지속 쿠키는 디스크에 저장되어 브라우저를 닫거나 컴퓨터를 재시작 하더라도 남아있다. 사용자가 주기적으로 방문하는 사이트에 대한 정보나 로그인 이름을 유지하려고 한다.

결과적으로 이 둘의 차이는 파기되는 시점 뿐이다. 쿠키는 Discard 파라미터가 설정되어있거나 Expires, Max-Age가 없으면 자동으로 세션쿠키가 된다.

---

### 쿠키는 어떻게 동작할까

쿠키는 사용자를 식별하기 위한 유일한 값을 쿠키에 할당하낟. Set-Cookie 같은 HTTP응답 헤더에 기술되어 사용자에게 전달한다.

쿠키는 어떤 정보도 포함할 수 있지만 서버가 사용자 추적용도로 생성한 유일한 단순 식별 번호만 포함하기도 한다.

해당 쿠키들에 대한 정보를 브라우저 쿠크 데이터베이스에 저장하고 추후에 방먼하면 브라우저는 서버가 이 사용자에게 할당한 쿠키를 요청 헤더에 기술한다.

---

### 사이트마다 각기 다른 쿠키들 

브라우저는 쿠키를 저장하지만 쿠키를 모든 사이트에 보내지는 않고 각 사이트에 2개 혹은 3개의 쿠키만을 보낸다. 이유는 다음과 같다

 - 쿠키를 모두 전달하면 HTTP요청 헤더 자체가 무거워져 성능이 크게 저하되며, 실제 콘텐츠보다 더많은 쿠키 바이트를 전달하게 된다.
 - 서버에 특화된 이름/값 쌍을 포함하고 있기 때문에 대부분 사이트에서는 인식하지 않는 값들이다.
 - 모든사이트에 쿠키를 전달하는것은 신뢰하지 않는사이트에서 가져갈 수 있어서 개인정보 문제가 발생할 수 있다.

#### 쿠키 Domain 속성
서버는 쿠키를 생성할때 Set-Cookie의 응답헤더에 Domain 속성을 기술 할 수 있다. 해당속성을 기술하면
어떤 사이트가 해당 쿠키를 읽을 수 있는지 제어할 수 있다.

해당 속성이 적용된 사이트에 접근하면 domain이 설정된 쿠키헤더가 항상 적용될 것이다.

#### 쿠키 Path 속성

path 속성을 사용하면 해당 path에 정의된 경로로 ㅈ버근하게 되면 해당 쿠키들을 읽어 올 수 있다.
```
Set-cookie: ... path=/sample/
```

xxx/sample/xxx.html 로 접근하면 해당 쿠키 사용 가능 

---

### 쿠키 구성 요소

쿠키에는 `Version 0 쿠키` 와 `Version 1 쿠키`가 있으며 Version 1 쿠키는 0 쿠키의 확장으로
널리 쓰이지는 않는다.

두개다 HTTP/1.1명세 일부로 기술되어있지 않다.

### Version 0(넷스케이프) 쿠키

Set-Cookie 응답 헤더와 Cookie 요청 헤더와 쿠키를 조작하는 데 필요한 필드들을 정의하였다. 
version 0 쿠키는 다음과 같은 형태를 갖는다

```
Set-Cookie: name=value [; expires=date] [; path=path] [; domain=domain] [; secure]
Cookie: name1=value1 [; name2=value2]...
```

#### Version 0 SetCookie 헤더는 쿠키의 이름과 값을 가져야 하며, 속성들을 세미콜론으로 구분한다.

- 이름=값(필수) : 큰 따옴표로 감싸지 않은 문자열이며 세미콜론 , 쉼표, 등호, 공백을 포함하지 않는 문자열이어야 한다.
- Expires(선택) : 쿠키의 생명주기를 가리키는 날짜 문자열을 기술한다. 해당 Expires에 정의된 시간을 넘으면 삭제되며, 전달되지 않을것이다.
- domain(선택) : 도메인을 사용하는 서버 호스트명으로만 쿠키를 전송한다. 도메인이 명시되지 않으면서버의 호스트명을 기본값으로 갖는다.
- Path(선택) : 서버에 있는 특정 경로에만 쿠키를 할당할 수 있다. 만약 Path에 기술된 값이 URL 경로의 앞부분과 일치하면 쿠키를 전송한다.
- Secure(선택) : 쿠키는 HTTP가 SSL보안을 사용할때만 쿠키를 전송한다.

---

### Version 1(RFC 2965) 쿠키

쿠키의 확장된 버전이며 Set-Cookie2와 Cookie2 헤더를 소개하며 Version 0과도 호환이 된다. 해당 Version1 쿠키는
기존의 Version 0보다 좀 더 복잡하며 모든 브라우저가 완전히 지원하지는 않는다 (현재는 폐기되어 더이상 지원하지 않는다.)

지원하지 않기 때문에 이하 설명 생략

---


### 쿠키와 캐싱 

쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다. 이유는 이전 사용자의 쿠키가 다른 사용자에게
할당되거나 다른사람에게 나의 개인 정보가 노출 될 수 있기 때문이다.

쿠키와 캐싱에 관련된 규칙은 잘 정리되어있지 않다. 기본원칙은 다음과 같다.

#### 캐시되지 말아야 할 문서가 있다면 표시하라. 

문서를 캐시하면 될지는 소유자가 정할 수 있다. 따라서 Set-Cookie헤더를 제외하고 캐시를 해도 되는 경우라면 명시적으로
Cache-Control: no-cache="Set-Cookie" 를 명시하면 된다. 만약 캐시를 ㅐㅎ도 된다면 Cache-Control: public 을 사용하면 웹의 대역폭을 더 절약해준다.

#### Set-Cookie 헤더를 캐시 하는것에 유의하라 

응답이 Set-Cookie를 가지고 있다면 본문은 캐시할 수 있지만 주의를 기울여야 한다.같은 쿠키를 여러 사용자에게 보내면
추적에 실패하기 때문이다. 해당 문제를 해결하기 위해서는 Cache-Control: must-revalidate, max-age=0 을 설정함으로 써 보수적인 캐시는 콘텐츠가
캐시해도 되는 데이터라고 하더라도 Set-Cookie 헤더를 가지는 응답은 캐시하지 않을 수 있다.


#### Cookie 헤더를 가지고 있는 요청을 주의하라.

요청이 Cookie 헤더와 함께온다면 개인 정보를 담고 있을 수 있다는 힌트이다. 개인정보는 캐시되지 않도록 표시되어 있어야 하지만
표시를 하지 않는 서버도 있다.

보수적인 캐시는 Cookie 헤더가 포함된 요청에 응답으로 오는 문서는 캐시하지 않는다. 더 효율적인 방식은
캐시 이미지에 파기시간이 0인 Cookie 헤더를 설정해 매번 재검사 하도록 강제하는 것이다.

---
