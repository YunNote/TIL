# Chapter 6 - 프록시

---

> 웹 프록시는 중개자이다. 클라이언트와 서버 사이에 위치하여 HTTP 메시지를 정리하는 중개인처럼 동작한다.

해당 챕터 에서는 다음과 같은 내용을 알아본다
1. HTTP프록시와 웹 게이트웨이를 비교하고 HTTP프록시가 어떻게 배치되는지 알아본다
2. 유용한 활용방법을 알아본다.
3. 프록시가 실제 어떻게 배치되어있는지. 트래픽이 어떻게 프록시 서버로 가게되는지
4. 브라우저에서 프록시를 사용하는 방법
5. HTTP 프록시 요청이 서버요청과 어떻게 다른지, 어떻게 프록시가 브라우저의 동작을 미묘하게 바꾸는지.
6. 프록시 서버들을 통과하는 메시지의 경로를 Via헤더와 Trace메서드를 이용해 기록하는 방법
7. 프록시에 기반한 HTTP 접근제어 
8. 어떻게 프록시가 클라이언트와 서버 사이에서 각각의 다른 기능과 버전들을 지원하면서 상호작용 할 수 있는지.


---

### 🧐 웹 중개자

웹 프록시 서버는 클라이언트의 입장에서 트랜잭션을 수행하는 중개인이다. 웹 프록시가 없다면
클라이언트는 HTTP서버와 직접 통신한다. 

HTTP프록시 서버는 웹서버 이기도 하지만 웹 클라이언트 이기도 하다. 

프록시는 HTTP 클라이언트의 요청을 받게됨으로 반드시 웹 서버처럼 요청을 서버로 보내기도 하고, 또한 응답을 돌려줘야 한다.

만약 HTTP 프록시를 직접 만든다면 클라이언트와 서버의 양쪽 규칙 모두를 주의깊게 따라야 한다.

### 🧐 개인프록시, 공유프록시 

> 프록시 서버는 하나의 클라이언트가 독점할수도, 여러 클라이언트가 공유할 수도 있다. 
> 하나의 프록시가 독점하는것을 개인프록시, 다수가 함께 사용하는것을 공용프록시라고 한다.

---

#### 공용 프록시
대부분의 프록시는 공용이며 공유된 프록시 이다. 중앙 집중형 프록시를 관리하는것이 비용적으로 효율이 높고 쉽다

#### 개인 프록시
개인 프록시는 흔하지는 않지만 꾸준히 사용되고 있다.

---

### 🧐 프록시 vs 게이트웨이

프록시는 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결하고, 게이트 웨이는 서로 다른 프로토콜을 사용하는 둘 이상을 연결한다.

게이트웨이는 클라이언트와 서버가 서로 다른 프로토콜로 말하더라도 서로 간의 트랜잭션을 완료할 수 있도록 해주는 프로토콜 변환기 처럼 동작한다.

프록시와 게이트웨이는 실질적으로 차이점은 모호하다, 브라우저와 서버느 다른 버전의 HTTP를 구현하기 때문에, 프록시는 때때로 약간의 프로토콜 변환을 하기도 한다.

상용 프록시 서버는 SSL 보안 프로토콜, SOCKS 방화벽, FTP접근등 웹 기반 애플리케이션을 지원하기 위해 게이트웨이 기능을 구현한다.

---

### 🧐 프록시를 왜 사용해야 하는가?

프록시 서버는 실용적이고 유용한 것이라면 무슨 일이든 한다. 보안을 개선하고, 성능을 높여주며, 비용을 절약한다. 프록시 서버는 모든 
HTTP 트래픽을 들여다보고 건드릴 수 있기 때문에, 프록시는 부가적인 가치를 주는 여러 유용한 웹 서비스를 구현하기 위해 트래픽을 감시하고 수정할 수 있다.

특정 요청에 대해서 접근제어를 할 수 있다. (도서 그림 6-3참고)


### 문서 접근 제어자
프록시 서버는 많은 웹 서버들과 웹리소스에 대한 단일한 접근 제어 전략을 구현하고 감사 추적하기 위해 사용 될 수 있다.

클라이언트마 각기 다른 접근제어를 통해 중앙 프록시 서버에서 접근 제어를 설정한다.

### 보안 방화벽 
프록시를 사용하면 트래픽을 살표볼 수 있는 후크기능을 제공하며, 조직안에 들어오거나 나가는 응용 레벨 프로토콜의 흐름을 네트워크의 한 지점에서 통제 가능하다.

### 웹 캐시
프록시 캐시는 인기있는문서의 로컬 사본을 관리하고 해당 문서에 대한 요청이 오면 빠르게 제공하여, 느리고 비싼 인터넷 커뮤니케이션을 줄인다.

### 대리 프록시
어떤 프록시들은 웹 서버인것처럼 위장한다, 이러한 방법으로 대리 or 리버스 프록시로 불리는 서버들은 진짜 웹 서버의 요청을 받지만
웹서버와는 달리 요청 받은 콘텐츠의 위치를 찾기위해 다른 서버와 커뮤니케이션을 한다.

대리 프록시는 공용 콘텐츠에 대한 느린 웹 서버의 성능을 개선하기 위해 사용도 가능하다.

### 콘텐츠 라우터

프록시 서버는 인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹서버로 유도하는 콘텐츠 라우터로 동작할 수 있다.
자신의 위치로 부터 가까운 캐싱 프록시에 가도록 콘텐츠 라우터를 통해 설정 가능.

### 트랜스코더

프록시 서버는 콘텐츠를 클라이언트에게 전달하기 전에 본문 포맷을 수정할 수 있다. 이와 같이 데이터의 표현 방식을 자연스럽게 변환하는것을 트랜스코딩이라고 부른다.

하나의 예로 트랜스코딩 프록시는 크기를 줄이기 위해 자신을 거쳐가는 GIF확장자에 대해서 JPG 이미지로 변환할 수 있다.

### 익명화 프록시
익명화 프록시는 HTTP 메시지에서 신원을 식별할 수 있는 특성( 클라이언트 IP주소, From 헤더, Referer 헤더, 쿠키, URI 세션 아이디)들을 적극적으로 제거함으로써 개인 정보 보호와 익명성을 보장한다.

예로들면 A클라이언트가 요청을 보냈을때 익명화 프록시에서 공통 식별 헤더정보를 제거하여 서버에 전송하는 예가 있다.

---

### 🧐 프록시는 어디에 있는가?

- 어떻게 프록시가 네트워크에 배치되는가
- 어떻게 프록시의 연쇄가 계층을 이루는가 
- 어떻게 트래픽이 올바르게 프록시를 찾아가는가

#### 프록시 서버 배치

#### 1. 출구 프록시
> 로컬 네트워크와 더 큰 인터넷 사이를 오가는 트래픽을 제어하기 위해 프록시를 로컬 네트워크의 출구에 넣을 수 있다. 외부로 나가는 트래픽에 대해서 출구 프락시를 사용하면
> 방화병 or 트래픽의 성능을 개선하기 위해 사용한다.

#### 2. 접근 프록시
> 고객으로부터 모든 요청을 종합적으로 처리하기 위해 프록시는 ISP접근 지점에 위치한다. 다운로드 속도를 개선하고 인터넷 대역폭 비용을 줄이기 위해
> 캐시 프록시를 사용해 많이 찾는 문서들의 사본을 저장한다.

3. 대리 프록시
> 프록시는 종종 대리 프록시(리버스 프록시라고도 한다)로 사용한다.
> 네트워크의 가장 끝에 있는 웹서버들의 바로앞에 위치하여 웹서버로 향하는 모든 요청을 처리하고 필요할 때만 웹서버에게 자원을 요청할 수 있는 접근제어를 한다.
> 
> 대리 프록시는 일반적으로 웹 서버의 이름과 IP주소로 스스로를 가장하기 때문에 모든 요청은 반드시 서버가 아닌 해당 프록시로 간다.

4. 네트워크 교환 프록시
> 캐시를 이용해 혼잡을 완화하고 트래픽의 흐름을 감시하기 위해 충분한 처리 능력을 갖춘 프록시가 네트워크 사이의 인터넷 피어링 교환 지점들에 놓일 수 있다.

---

### 🧐 프록시 계층
프록시 들은 프록시 계층이라고 불리는 연쇄프록시를 구성할 수 있다.
메시지는 최종적으로 원 서버에 도착할 때까지 프록시와 프록시를 거쳐서 이동한다. 

서보쪽에 가까운 프록시를 부모라고 부르고 , 클라이언트에 가까운 쪽은 자식 프록시라고 부른다.

자식 부모관계라고 하여 항상 프록시가 정적으로 전달되는것은 아니다. 프록시 서버는 여러 가지 판단 근거에 의해 메시지를 다양하고
유동적은 프록시 서버와 원 서버들의 집합에게 보낼 수 있다.

동적 부모 선택의 예를 들면 다음과 같다

 - 부하 균형
   - 자식 프록시는 부하를 분산하기 위해 현재 부모들의 작업량 수준에 근거하여 부모 프록시를 선택한다.
 - 지리적 인접성에 근거한 라우팅
   - 자식 프록시는 원 서버의 지역을 담당하는 부모를 선택할 수 있다.
 - 프로토콜/타입 라우팅
   - 자식 프록시는 URI에 근거하여 다른 부모나 원 서버로 라우팅할 수 있다.

---

### 🧐 어떻게 프록시가 트래픽을 처리하는가 
클라이언트는 보통 웹 서버와 직접 대화하기 때문에 어떻게 HTTP트래픽이 프록시로 향하는 길을 찾아내는지
설명할 필요가 있다. 프록시에게 가도록 하는 방법에는 다음 네가지가 있다.

#### 1. 클라이언트를 수정한다.
> 크롬과 MS등의 브라우저를 포함한 많은 웹 클라이언트들은 수동 or 자동으로 프록시 설정을 지원한다. 만약 클라이언트가
> 프록시를 사용하도록 설정되어있다면 클라이언트는 HTTP 요청을 바로 원서버가 아닌 프록시서버로 보낸다.

#### 2. 네트워크를 수정한다
> 스위칭 장치와 라우팅 장치를 톡해 트래픽을 프록시에게 보낼 수 있다.

#### 3. DNS 이름 공간을 수정한다.
> 웹서버 앞에 위치하는 프록시 서버인 대리 프록시는 웹 서버의 이름과 IP주소를 자신이 직접 사용한다
> 
> 그래서 모든 요청은 서버 대신 대리 프록시로 간다. 이는 DNS이름 테이블을 수동으로 편집하거나 적절한 프록시나
> 서버를 계산해주는 특별한 동적 DNS 서버를 이용하여 조정될 수 있다.

#### 4. 웹 서버를 수정한다.
> HTTP 리다이렉션 명령을 클라이언트에게 돌려줌으써 클라이언트의 요청을 프락시로 리다이렉트 하도록 설정할 수 있다.

---

### 🧐 클라이언트 프록시 설정 

1. 수동설정
2. 브라우저 기본 설정
3. 프록시 자동 설정
4. WPAD 프록시 발견

#### 수동 설정 
> 프록시를 사용하겠다고 명시적으로 설정한다.

#### 브라우저 기본 설정
> 브라우저 벤더나 배포자는 브라우저를 소비자에게 전달하기 전에 프록시를 미리 설정해 놓을 수 있다.

#### 프록시 자동 설정
> 자바스크립트 프록시 자동 설정파일에 대한 URI를 제공할수 있다. 클라이언트는 어떤 프록시를 써야하는지
> 판단하기 위해 자바스크립트 파일을 가져와서 실행한다.

#### WPAD 프록시 발견 
> 대부분의 브라우저는 자동 설정 파일을 다운받을 수 있는 설정 서버를 자동으로 찾아주는 웹프록시 자동 발견 프로토콜을 제공한다.

---

###  클라이언트 프록시 설정 : 수동  
많은 웹클라이언트가 프록시를 수동으로 간편하게 설정할 수 있도록 하고 있다.

각각 브라우저의 옵션에서 프록시를 설정할 수 있다.


###  클라이언트 프록시 설정 : PAC파일 
수동 프록시 설정은 비교적 간단하지만 유연하지 못하다. 모든 콘텐츠를 위해 단 하나의 프록시 서버만 지정할 수 있다.
또한 장애시 대체 작동에 대한 지원도 없다, 또한 수동 프록시 설정은 큰 조직에서는 관리 문제를 야기한다.

만약 설정된 브라우저가 많다면 모두 원하는 대로 설정 변경을 하는것은 어렵거나 불가능하다고 본다.

이러한 문제떄문에 PAC파일을 사용하면 그때그때 적절한 상황에 마젝 계산해주는 스크립트를 읽어 프록시를 설정한다.

일반적으로 PAC파일은 `.pac`확장자를 사용하며 `application/x-ns-proxy-autoconfig` MIME타입을 사용한다.

각 PAC파일은 URI에 접글할 때 사용할 적절한 프록시 서버를 계산해주는 FindProxyForUri라는 함수를 정의해야 한다.

반환값은 다음과 같다 
- `DIRECT` : 프록시 없이 연결이 직접 이루어져야 한다.
- `PROXY host:port` : 지정한 프록시를 사용해야 한다.
- `SOCKS host:port` : 지정한 SOCKS 서버를 사용해야 한다.

설정 내용은 P.163의 예 6-1을 참고하면 된다.

###  클라이언트 프록시 설정 : WPAD

웹 프락시 자동발견 프로토콜(WPAD)는 여러 발견 메커니즘들의 상승전략을 이용하여 브라어주에게
알맞은 PAC파일을 자동으로 찾아주는 알고리즘이다. WPAD프로토콜이 구현된 클라이언트는 다음과 같은 일을 한다.

1. PAC URI를 찾기 위해 WPAD를 사용한다
2. 주어진 URI에서 PAC파이릉ㄹ 가져온다.
3. 프록시 서버를 알아내기 위해 PAC파일을 실행한다.
4. 알아낸 프록시 서버를 이용하여 요청을 처리한다.

WPAD는 올바른 PAC를 알아내기 위해 리소스 발견 기법을 사용하는데 20장에서 상세 설명.


---

### 🧐 프록시 요청의 미묘한 특징

#### 프록시 URI는 서버 URI와 다르다.

웹 서버와 웹 프록시 메시지의 문법은 서로 같지만, 한가지 예외가 있다면 클라이언트가 프록시 대신 
서버로 요청을 보내면 요청의 URI가 달라진다.

클라이언트가 웹서버로 호출하게 되면 요청줄에는 예와 같이 스킴, 호스트, 포트번호가 없는 부분URI를 갖는다.

P.164 참고 

하지만 프록시로 호출을 하면 요청줄은 완전한 URI를 갖는다.

프록시를 사용하지 않는다면 단일 웹서버와 통신하기 때문에 자신의 호스트명과 포트번호를 알고 있으므로 클라이언트는
불필요한 정보 발송을 피하기 위해 스킴과 호스트가 없는 부분 URI 만 보낸다.

정리하면 클라이언트가 프록시를 사용하지 않는다면 부분 URI를 보내고, 프록시를 사용한다면 완전한 URI를 보낸다.

---

#### 가상 호스팅에서 일어나는 같은 문제

프록시의 `스킴/호스트/포트번호 누락`문제는 가상 호스팅되는 웹 서버가 직면한것과 같은 문제다.

가상으로 호스팅되는 서버는 여러 웹 사이트가 같은 물리적 웹 서버를 공유한다. 웹 서버로 요청을 하면
호스팅되는 웹 서버는 해당 요청이 접근하고자 하는 웹사이트의 호스트 명을 알 필요가 있다.

P.166

---

#### 인터셉트 프록시는 부분 URI를 받는다.

클라이언트가 HTTP를 올바르게 구현했따면 명시적으로 설정된 프록시에게는 완전한 URI를 보낸다.

이것으로 일부분은 해결되지만 여전히 남은문제가 있다. 클라이언트는 자신이 프록시와 대화하고 있음을 항상
알고있는것은 아니다, 왜냐하면 몇몇의 프록시들은 클라이언트에게는 노출되지 않기 때문이다.

클라이이언트가 프록시 설정을 한다고 설절하지 않아도 클라이언트의 트래픽은 여전히 대리 프록시나 인터셉트 프락시를 지날 수 있다.

---

#### 프록시는 프록시 요청과 서버 요청을 모두 다룰 수 있다.

다목적 프록시 서버는 요청 메시지의 완전한 URI와 부분 URI를 모두 지원해야 한다. 명시적인 요청에 대해서는
완전한 URI를 제공하고 아닌 경우에는 부분 URI를 제공해야 한다.

부분URI를 제공받았다면 Host헤더가 없는 경우 다음 방법으로 원 서버를 찾아낼 수 있다.
 - 프록시가 원서버를 대신하는 대리 프록시라면 해당 프록시에 실제 서버의 주소와 포트번호가 설정되었을 수 있따.
 - 이전에 어떤입터셉트 프록시가 가로챘던 트래픽을 받았다면, IP주소와 포트번호를 사용할 수 있다.
 - 모두 실패했다면 원 서버를 알아낼 수 있는 충분한 정보를 갖고있지 못한것이므로 반드시 에러 메시지를 반환해야 한다.


---

#### 전송중 URI 변경 
프록시 서버는 요청 URI의 변경에 매우 신경을 써야한다. 사소한 URI변경이라도 다운 스트림 서버와의
상호작용에서 문제를 발생시킨다.

---

#### URI 클라이언트 자동확장과 호스트명 분석

브라우저는 프록시의 존재 여부에 따라 URI를 다르게 분석한다.

프록시가 없다면 사용자가 타이핑한 URI를 가지고 IP를 찾는다. 만약 호스트명이 발견되면 그에 대응하는 IP주소들을 연결에 성공할때 까지 시도한다.

그러나 발생하지 않는다면 약어를 타이핑한것이라 보고 자동화된 호스트명의 확장을 제공한다

---

#### 프록시 없는 URI 분석 

브라우저는 명시적인 프록시가 존재 하지 않는다면 부분 호스트명을 자동으로 확장한다
ex) aaa 검색시 없다면 www.aaa.com으로 자동 확장 

---

#### 명시적 프록시를 사용할때의 URI 분석 

만약 명시적 프록시를 사용한다면 브라우저는 편리한 확장들중 어느것도 수행할 수 없다. 브라우저의 URI가 프록시를
그냥 지나쳐버리기 때문이다. 이러한 이유로 몇몇 프록시는 자동확장이나 지역 도메인 접미사 추가와 같은
기능을 최대한 흉내 내려고 시도한다.

---

#### 인터셉트 프록시를 이용한 URI 분석 

호스트명 분석은 보이지 않는 인터셉트 프락시와 함꼐일때 약간 달라진다, 클라이언트 입장에서 프록시는 존재하지 않는것이기 때문이다.

---

### 🧐 메시지 추적

오늘날 웹 요청의 상당수가 프록시를 지나간다. 동시에 성능상의 이슈로 곳곳에 흩어져 있는 대리 캐시 저장고에
콘텐츠를 복제해 두는 방식이 점점 더 흔해지고 있다.

프록시가 점점 흔해지면서 서로 다른 스위치와 라우터를 넘나드는 IP패킷에 흐름을 추적하고 문제점을 찾아내는것도 필요한 일이 되었다.

---

#### Via 헤더
> Via헤더 필드는 메시지가 지나는 각 중간노드의 정보(프록시나 게이트웨이)를 나열한다. 메시지가 또다른 노드를 지날때마다
> 중간 노드는 Via목록의 끝에 반드시 추가되어야 한다.
> 
> P.173 via 그림 6-20 참고 

via 헤더 필드는 쉼표로 구분된 경유지의 목록이다, 각 경유지는 개별 프록시 서버나 게이트웨이 홉을 나타내며 그들 중간 노드의 
프로토콜과 주소에 대한 정보를 담고있다.

Via헤더의 형식은 P174 참고.

각 Via Waypoint는 프로토콜 이름(선택), 프로토콜 버전(필수), 노드이름(필수), 코멘트(선택)의 최대 4개의 구성요소를 담을 수 있다.


 - `프로토콜 이름` : 중개자가 받은 프로토콜, 만약 HTTP라면 프로토콜 이름은 없어도 된다, 프로토콜 이름은 버전 앞에 /로 구분되어 붙는다. 비 HTTP 프로토콜은 게이트웨이가 다른 프로토콜(HTTPS, FTP등)을 위해 HTTP요청에 접속할 때 발생할 수 있다.
 - `프로토콜 버전` : 수진한 메시지의 버전을 의미하며, 버전의 포맷은 프로토콜에 달려있다. HTTP의 경우 표준번호 1.0, 1.1등이 사용된다. Via를 보고 각 애플리케이션들은 이전의 중개자들에 대해서 어떠한 버전을 다룰 수 있는지 알 수 있다.
 - `노드 이름` :  중개자의 호스트와 포트 번호, 만약 포함되어있지 않다면 프로토콜의 기본 포트라고 간주한다. 몇몇 조직은 밝히고 싶지 않을 수 있어 가명으로도 대체 가능하다. 
 - `노드 코멘트` : 중개자 노드를 서술하는 선택적인 코멘트이며, 벤더나 버전 정보를 포함시키는것은 흔한일이며, 이벤트의 진단 정보를 포함하는 데도 코멘트 필드를 사용한다.

---

#### Via 요청과 응답 경로

요청 메시지와 응답 메시지모두 프록시를 지나기 때문에 둘 모두 Via 헤더를 가진다. 보통 요청,응답 메시지 는 같은 TCP커넥션을 오고가기 떄문에 같은 경로를 되돌아간다.

A -> B -> C 로 요청이 지나갔다면 응답은 C -> B -> A로 지나간다.

요청 메시지의 Via헤더는 응답 메시지의 Via헤더의 반대이다.

#### Via 게이트웨이 
몇몇 프록시는 서버에게 비 HTTP프로토콜을 사용할 수 있는 게이트웨이 기능을 제공한다.

Via헤더는 이러한 프로토콜 변환도 기록하기 때문에 어떠한 변환이 있었는지를 Via헤더 를 통해 알 수 있다.


#### Server헤더와 Via헤더 

Server 응답 헤더 필드는 원 서버에 의해 사용되는 소프트웨어를 알려준다.

응답 메시지가 프록시를 통과할때 프록시는 Server 헤더를 수정해서는 안된다, 대신 프록시는 Via항목을 추가해야 한다.

---

#### Via가 개인정보 보호와 보안에 미치는 영향 

보통 프록시서버가 네트워크 방화벽의 일부인 경우 프록시는 방화벽 뒤에 숨어있는 호스트의 이름과 포트를 전달해서는 안된다.
이유는 악의적인 집단에 의해 이용될수있기 때문이다.

만약 Via노드 이름 전달이 가능하지 않다면 보안상 적당한 가명으로 교체해야 한다. 하지만 가명을 사용하면 실제 이름을 알기 어렵게 되었다고 하더라도
일반적으로 프록시는 각 프록시 서버에 대한 Via 경유지 항목을 유지하려 노력해야 한다.

정렬된 일련의 via 경유지 항목들을 하나로 합칠 수 있다. 
다만 모두 같은 조직의 통제하에 있고 호스트가 이미 가명으로 교체되지 않는 이상 그들에 대한 항목들을 합쳐서는 안된다. 
수신된 프로토콜 값이 서로 다른 항목들도 합쳐서는 안된다.