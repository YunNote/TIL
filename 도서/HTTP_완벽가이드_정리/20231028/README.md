# 14장 보안 HTTP

---

## HTTP를 안전하게 만들기

웹이 발전해가면서 점차 웹에서 다양한 경험을 제공한다. 따라서 보다 이식성이 좋아야 하고, 관리가 쉬워야 하며, 다양한 변화에 대한
적응력이 좋아야 한다. 따라서 HTTP보안기술이 필요하다.

- 서버 인증 : 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야 한다.
- 클라이언트 인증 : 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기 하고있음을 알아야 한다.
- 무결성 : 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야한다.
- 암호화 : 클라이언트와 서버는 도청에대한 걱정 없이 서로 대화할 수 있어야 한다.
- 효율 : 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.
- 편재성 : 프로토콜은 거의 모든 클라리언트와 서버에서 지원되어야 한다.
- 관리상확장성 : 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
- 적응성 : 현재 알려진 최신의 보안 방법을 지원해야 한다.
- 사회적 생존성 : 사회의 문화적 정치적 요구를 만족해야한다.

---

### HTTPS 

> HTTPS는 HTTP를 안전하게 만드는 방식 중에서 가장 인기가 있다. 거의 모든 브라우저와 서버에서 지원한다.<br>
> HTTP가 아닌 HTTP로 접근하고 있는 경우 URl의 프로토콜은 http:// 대신 https://로 시작하는 것을 보고 알 수 있다.

HTTPS를 사용한다면 요청과 응답데이터는 네트워크로 보내기지 전에 암호화 된다.<br>
HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작하며, 안전 소켓 계층(SSL) 혹은 그를 계승한 전송계층보안(TLS)를
이용하여 구현된다.

SSL과 TLS는 매우 비슷하여 해당 도서에서는 SSL 단어를 사용하기로 한다.

HTTPS의 어려운 인코딩 및 디코딩은 대부분 SSL 라이브러리에서 처리하기때문에 웹 클라이언트와 서버가 프로토콜을 처리하는
로직을 크게 변경할 필요가 없다.

대부분의 경우 입출력호출을 SSL호출로 대체하고 보안 정보를 설정하여 몇가지만 호출하면 된다.

---

## 디지털 암호학 

> 암호법은 메시지를 볼 수 없게 암호활 뿐만 아니라 변조를 방지하기 위해 사용할 수도 있다.
디지털 암호화에서는 다음과 같은 주요 내용이 있다.

1. 암호
2. 키
3. 대칭키 암호 체계
4. 비대칭키 암호 체계
5. 공개키 암호법
6. 디지털 서명
7. 디지털 인증서

---

### 암호(cipher)
> 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘 

암호법은 암호라 불리는 비밀 코드를 기반으로 한다. 암호란 메시지를 인코딩하는 특정한 방법과 그 인코딩된 비밀 메시지를
디코딩 하는 방법이다. 

인코딩 되기 전의 데이터를 `평문`이라고 부르며, 암호가 적용되어 코딩된 메시지는 보통 `암호문`이라고 부른다.

> 평문 -> 인코등 -> 암호문 -> 디코등 -> 평문

---

### 암호 기계

초기 암호는 상대적으로 간단한 알고리즘으로 작성되었다. 이유는 사람이 직접 인코딩, 디코딩을 해야했기 때문이다.
따라서 암호가 간단하기 때문에 암호를 깨뜨리는것 또한 쉬웠다.

기술이 발전하면서, 사람들은 보다 복잡한 암호로 메시지르 빠르고 정확하게 인코딩, 디코딩 하는 기계를 만들기 시작하였다.

---

### 키가 있는 암호 

알고리즘과 기계는 해독이 될 수 있기 때문에 대부분의 기계들에는 암호의 동작 방식을 변경할 수 있는 큰 숫자로된
다른 값을 설정할 수 있는 다이얼이 달려있다. 누군가 기계를 훔치더라도 올바른 키가 없이는 디코더가 동작하지 않을것이다.

이러한 암호 매개변수를 `키`라고 부른다. 디코딩을 올바르게 하려면 해당 키를 암호 기계에 입력하면 된다.

---

### 디지털 암호

디지털 계산이 도래하면서 주요한 발전이 두가지 있다.

1. 속도 및 기능에 대한 기계 장치의 한계에서 벗어나서 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.
2. 큰 키를 지원하는것이 가능해져서, 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 암호 알고리즘을 만들어낼 수 있게 되었다. 따라서 무작위 추측을 이용한 공격이 어려워졌다.

물리적 키와 달리 디지털 키는 그냥 숫자에 불과하다, 따라서 디지털 키 값은 인코딩과 디코딩
알고리즘에 대한 입력값이다. 

---

## 대칭키 암호법

많은 디지털 암호 알고리즘은 대칭키 암호화라 불린다. 왜냐하면 인코딩을 할때 사용하는 키가 디코딩할때 사용하는 키와 같기 때문이다

대칭키 암호에서는 발송자와, 수신자가 모두 같은 키를 사용해야한다. 

대표적으로는 DES, Triple-DES, RC2, RC4 등이 있다.

---

### 키 길이와 열거 공격 (Enumeration Attack)

암호화시 비밀키가 노출되면 안되는것은 매우 중요하다. 인코딩 및 디코딩 알고리즘은 공개적으로 알려져있어 비밀키가 유일한 암호의 비밀이다.

좋은 알고리즘은 공격자가 모든 가능한 키값을 시도 해보는것 이외에는 방법이 없다. 무차별로 모든 키 값을 대입해 보는 공격을
열거 공격이라고 한다. 

만약 가능한 키 값이 몇가지 밖에 없다면 무차별 대입으로 모든 값을 시도하게되어 암호가 깨지게 된다.

암호의 키의 값은 2의 bit 승으로 계산된다 40 비트라면 2의 40승인 약 1조개 까지도 가능하다.

평범한 대칭키 암호에서 40비트는 작고 중요하지 않은 업무에는 충분하다고 판단하지만 초당 수십억번의 계산이 가능한
오늘날의 빠른 워크스테이션에는 쉽게 꺠진다.

글을 작성한 2023년 기준에는 더 빠르게 깰 수 있을것 같다.

---

### 공유키 발급하기.

대칭키 암호화의 단점은 발송자와 수신자가 서로 소통하기위해서는 공유키를 양쪽에서 가지고 있어야 한다.

대칭키의 경우에 개인키를 가져야 한다면 N의 2승개의 비밀키가 필요하게 된다 따라서 관리측면에서는 별로이다.

---

## 공개키 암호법

공캐이 암호 방식은 두개의 비대칭 키를 사용한다.

하나는 인코딩하기 위한것이며, 다른 하나는 호스트의 메시지를 디코딩 하기 위한 것이다.<br>
인코딩 키는 모두를 위해 공개되어있지만 호스트만이 개인 디코딩 키를 알고 있다.

이말은 대칭키 암호방식과 다르게 모든 인코딩키를 클라이언트들에게 공개하고, 메시지를 디코딩하는 능력은 디코딩하는
소유자에게만 부여한다. 

---

### RSA

MIT에서 발명하였으며 RSA 데이터 시큐리티에 상용화된 알고리즘이다

해당 RSA알고리즘의 개인키를 찾아내는 것은 컴퓨터 과학의 모든 분야에서 가장 어려운 문제중 하나이다.

---

### 혼성 암호 체계와 세션 키

비대칭 공개키 암호 방식은 누구나 공개키만 알면 그 키에 대응되는 공개 서버에 안전하게 메시지를 보낼수 있다. 두개의
노드가 안전하게 의사소통하려면 키에 대한 협상을 먼저 해야할 필요가 없다.

하지만 공개키 암호방식알고리즘의 단점은  계싼이 느린 경향이 있다, 실제로는 대칭키 암호 방식과 비대칭 방식을 섞어서 쓰기도 한다. 

안전한 의사소통을 할때는 공개 키 암호화 방식을 사용하고 이렇게 만들어진 채널을 통해 대칭키를 생성하고 교환하여 이후의 나머지 데이터를 
암호화할때는 빠른 대칭키를 사용하는 방식을 사용한다

---

## 디지털 서명 

암호 체계는 메시지를 암호화하고 해독하는 것뿐 아니라 누가 메시지를 썻는지 알려주며, 해당 메시지가
위조되지 않았는지 증명하기 위해 메시지에 서명을 하도록 하는데 사용될 수 있다.

---

### 서명은 암호 체크섬이다.

디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬이다.

- 서명은 메시지를 작성한 저자가 누군지 알려준다. 저자는 개인키를 갖고 있기 때문에 오직 저자만이 체크섬을 계산할 수 있다.
- 서명은 위조를 방지한다. 악의적인 공격자가 송신 중인 메시지를 수정했다면 체크섬은 메시지와 맞지 않게 된다. 따라서 위조된 메시지에 대한 올바른 체크섬을 날조해 낼 수 없다.

디지털 서명은 보통 비대칭 공개키에 의해 생성된다. 개인키는 오직 소유자만이 알고있어 저자의 개인 키는 일종의 지문처럼 동작한다.

---

## 디지털 인증서

디지털 인증서(certs)는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고있다.

여권이나 운전면허는 개인의 신원을 증명할 수 있을 정도로 신뢰를 받는다. 따라서 해당 디지털 인증서를 사용한다.

### 인증서의 내부 

디지털인증서에는 공식적으로 `인증 기관`에 의해 디지털 서명된 정보의 집합이 담겨있다. 기본적으로 다음과 같은것들이 담겨있다.

- 대상의 이름(사람, 서버, 조직등)
- 유효 기간
- 인증서 발급자(누가 이 인증서를 보증하는가.)
- 인증서 발급자의 디지털 서명

이 외에도 추가적으로 디지털 인증서는 대상과 사용된 서멍 알고리즘에 대한 서술적인 정보뿐만 아니라
보통 대상의 공개키도 담고 있다.

---
### X.509 v3 인증서

디지털 인증서에 대한 단일 표준은 없다. 모든 ID카드가 같은 위치에 같은 정보를 담고있지 않는것처럼
여러가지 미묘하게 다른 스타일의 디지털 인증서들이 존재한다. 오늘날 사용되는 대부분의 인증서가 그들의 정보를 X.509라 불리는
표준화된 서식에 저장하고 있다. 

X.509 v3인증서는 인증 정보를 파싱가능한 필드에 넣어 구조화 하는 표준화된 방법을 제공한다.

X.509들의 필드는 아래와 같다

- `버전` :X.509인증서의 버전 번호, 보통 요즘은 3버전이다.
- `일련 번호` : 인증기관에 의해 생성된 고유한 정수, CA로 부터의 각 인증서는 반드시 고유한 일련번호를 가져야한다.
- `서명 알고리즘 ID` : 서명을 위해 사용된 암호 알고리즘
- `인증서 발급자` : 인증서를 발급하고 서명한 기관의 이름 X.500 포맷으로 기록되어 있다.
- `유효 기간` : 해당 인증서가 유효한 기간을 정의하며, 시작일과 종료일로 정의된다.
- `대상의 이름` : 인증서에 기술된 사람이나 조직과 같은 엔티티, 
- `대상의 공개 키 정보` : 인증 대상의 공개 키, 공개 키에 사용된 알고리즘
- `발급자의 고유 ID(선택적)` : 발급자의 이름이 겹치는 경우를 대비한 인증서 발급자에 대한 선택적인 식별자
- `대상의 고유 ID(선택적)` : 대상의 이름이 겹치는 경우를 대비한 인증대상에 대한 선택적인 고유한 식별자.
- `확장` - 선택적인 확장 필드의 집합
- `인증기관 서명` : 위의 모든 필드에 대한 인증기관의 디지털 서명, 명시된 서명 알고리즘을 사용한다.

---

### 서버 인증을 위해 인증서 사용하기

사용자가 HTTPS를 통한 안전한 웹을 시작할떄 브라우저는 자동으로 접속한 서버에서
디지털 인증키를 가져온다. 만약 서버가 인증서를 가지고 있지 않다면, 보안 커넥션을 실패한다. 

서버 인증서는 다음을 포함한 많은 필드를 갖고 있다.

- 웹 사이트의 이름과 호스트명
- 웹 사이트의 공개키
- 서명 기관의 이름 
- 서명 기관의 서명

브라우저가 인증서를 받으면 서명 기관을 확인한다. 만약 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를
알고있을 것이며, 브라우저는 그 서명을 검증한다.

만약 서명 기관이 모르는 곳이라면 브라우저는 신뢰해야하는지 확인할 수 없어 사용자가 서명 기관을 신뢰하는지 확인하기 위한
대화상자를 보여준다.

---

## HTTPS의 세부 사항

HTTPS는 HTTP의 가장 유명한 보안 버전이다. 널리 구현되었으며 많은 브라우저 사이트들에 구현되어있다. 
HTTPS는 HTTP프로토콜에 대칭,비대칭 인증서 기반 암호 기법의 집합을 결합한 것이다. 
HTTPS는 글로벌 인터넷 환경에서도 HTTPS를 매우 안전하고 동시에 매우 유연하게 관리하기 쉽게 만들어준다.

---

### HTTPS 개요 

HTTPS는 그냥 보안 정송 계층을 통해 전송되는 HTTP이다. 암호화 되지 않은 HTTP메시지를 TCP를 통해 곳곳으로 보내는대신에
HTTPS는 HTTP 메시지를 메시지로 보내기전 암호화하는 보안계층으로 전달한다.

---

### HTTPS 스킴

오늘날 보안 HTTP는 선택적이다. 따라서 웹 서버로의 요청을 만들 때 우리는 웹서버에게 HTTP의 보안 프로토콜 버전을
수행한다고 말해줄 방법이 필요하다. 이것은 URL스킴을 사용하여 알려준다.

보안이 없는 HTTP의 스킴은 HTTP이다. 하지만 보안이 적용된 스킴은 HTTPS이다

만약 HTTP 스킴을 가지고 있다면 80포트로 연결하게 되고 HTTPS스킴을 가지고 있다면 클라이언트는 서버에 443포트로 기본으로 연결하게 된다.

---

### 보안 전송 셋업
HTTPS에서의 젗라는 SSL보안 계층때문에 기존 HTTP보다 더 복잡하다. HTTPS를 사용하면
클라이언트는 먼저 웹서버의 443 포트로 연결한다.

일단 TCP연결이 되고 나면 클라리언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL계층을 초기화하게 되고
핸드셰이크가 완료되면 SSL초기화는 완료되며, 클라이언트는 요청 메시지를 보안계층에 보낼 수 있다.

P.375 이미지는 따로 참고

---


### SSL 핸드셰이크

 암호화된 HTTP 메시지를 보낼 수 있기 전에 클라이언트와 서버는 SSL 핸드셰이크를 할 필요가 있다.
 
핸드셰이크시 다음과 같은 동작이 발생한다.

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성

암호화된 HTTP 데이터가 오가기도 전에 많은 양의 핸드셰이크 데이터를 주고 받는다. 

---


### 서버 인증서 

SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호 인증을 지원한다.

하지만 오늘날 클라이언트 인증서는 웹브라우징에서는 흔히 사용하지 않는다.  사용자가 개인 클라이언트 인증서를 갖고
있지도 않다.

하지만 보안 HTTPS 트랜잭션에서는 서버 인증서를 요구한다. 잘알려진 인증기관에 의해 서명된 서버 인증서는
데이터를 주고 받기전 얼마나 신뢰할 수 있는지 평가하는 것을 도와준다.

---

### 사이트 인증서 검사.

SSL자체는 사용자에게 웹 서버 인증서를 검증하는것을 요구하지 않지만 최신브라우저들은 대부분 인증서에 대해 간단하게
기본적인 검사를 하고 더철저한 사용방법을 사용자에게 알려준다.

웹브라우저의 검사 기법알고리즘의 수행단계는 다음과 같다.

#### 1. 날짜 검사
> 브라우저는 인증서가 여전히 유효한지 확인하기 위해 인증서의 시작 및 종료일을 검사한다.
> 만약 만료되었거나 아직 활성화 되지 ㅇ낳았다면 검사는 실패하고 브라우저는 에러를 보여준다.

#### 2. 서명자 신뢰도 검사
> 모든 인증서는 서버를 보증하는 어떤 인증 기관에 의해 서명되어 있다. 여러가지 인증서가 존재하며
> 각각 다른 수준의 배경 검증을 요구한다. 
> 
> 보통 브라우저는 신뢰할 만한 서명 기관의 목록을 포함한 채로 배포된다. 만약 알려지지 않은, 신뢰되지 않은 기관의
> 서명된 인증서를 받았다면 보통 경고를 보여준다.
> 
> 브라우저는 또한 신뢰할 만한 CA가 간접적으로 서명한 인증서를 받아들이는것을 선택할 수 있따.

#### 3. 서명 검사
> 한번 서명기관이 믿을만하다고 판단하면 브라우저는 서명기관의 공개키를 서명에 적용하여 체크섬고 비교함으로써
> 무결성을 검사한다.


#### 4. 사이트 신원 검사
> 서버가 다린이의 인증서를 복사하거나 트래픽을 가로채는 것을 방지하기 위해, 대부분의 브라우저는 인증서의 도메인 
> 이름이 대화중인 서버의 도메인 이름과 비교하여 맞는지 검사한다.
> 
> 보통 단일 도메인 이름이 들어있지만 몇몇 CA 는 서버 클러스터나 서버팜을 위해 서버의 목록이나
> 서버이름들에 대한 와일드카드 표현이 있는 인증서를 만든다. 만약 호스트명이 인증서의 신원과 맞지 않는다면
> 사용자를 우선으로 생각하는 클라이언트는 반드시 이 사실을 사용자에게 알리거나 잘못된 인증서 에러와 함께 커넥션을 끊어야한다.

---

### 가상 호스팅과 인증서

가상 호스트로 운영되는 사이트의 보안 트래픽을 다루는것은 까다옵다, 몇며 인기있는 웹 서버는 오직 하나의 인증서만을
지원한다. 만약 인증서의 이름과 정확히 맞지 않는 가상 호스트명에 도착했다면 경고가 발생할 것이다.

따라서 가상호스팅되는 사이트들은 모든 요청에 대해서 인증서에 등록된 도메인으로 리다이렉트 한다.

---