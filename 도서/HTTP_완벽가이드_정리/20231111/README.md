
# 15장 엔터티와 인코딩

HTTP는 메시지가 올바르게 수송되고, 식별되고, 추출되고, 처리하는것을 보장하기위해 잘 라벨링된 엔티티를 사용한다.

해당 15장에서는 다음내용들을 다룬다.

- HTTP 데이터를 담는 컨테이너인 HTTP 메시지 엔티티의 포맷과 동작방식
- 어떤게 HTTP가 본문의 크기를 기술하며, 크기를 측정하기위해 무엇을 요구하는지.
- 콘텐츠를 바르게 처리할 수 있도록 제공되는 엔티티 헤더들
- 데이터 포맷을 변형할때 사용하는 디코딩 가능한 콘텐츠 인코딩
- HTTP가 데이터를 실어 나르는 방식을 수정하는 전송인코딩, 청크인코딩
- 클라이언트가 요청한 최신 콘텐츠의 버전을 가져올 수 있도록 도와주는 태그, 라벨, 시간, 체크섬
- 중단되었던 다운로드를 중단된 지점에서부터 재개하고자 할때 유용한 범위 요청
- 본적있던 웹페이지를 다시 볼 때 그때 이후로 변경이 있는 부분만 요청할 수 있게 해주는 HTTP 델타 인코딩 확장
- 엔티티 콘텐츠가 프록시를 지나는 과정에서 변경된 곳이 있지 않은지 탐지하기 위해 사용하는 엔티티 본문의 체크섬

---

## 메시지는 컨테이너, 엔티티는 화물

HTTP메시지를 컨테이너라고 생각하면 HTTP 엔티티는 메시지의 실질적인 화물이다.

HTTP/1.1은 다음과 같으 주요 10가지 엔티티 헤더 필드를 정의하였다.

`Content-Type` - 엔티티에 의해 전달된 객체의 종류 <br>
`Content-Length` - 전달되는 메시지의 길이나 크기 <br>
`Content-Language` - 전달되는 객체와 가장 잘 대응되는 자연어 <br>
`Content-Location` - 요청 시점을 기준으로 객체의 또다른 위치 <br>
`Content-Range` -  해당 엔티티가 전체에서 어느 부분에 해당하는지 정의 <br>
`Content-MD5` - 엔티티 본문의 콘텐츠에 대한 체크섬 <br>
`Last-Modified` - 콘텐츠가 생성된날 혹은 수정된 날 <br>
`Expires` -  엔티티의 만료 날짜와 시각 <br>
`Allow` - 리소스에 대해 어떤 요청 메서드가 허용되는지 <br>
`ETag` - 인스턴스에 대한 고유한 검사기 <br>
`Cache-Control` - 해당 문서가 캐시될 수 있는지에 대한 지시자 <br>

### 엔티티 본문

엔티티 본문은 가공되지 않은 데이터만을 담고 있다. 다른 정보들은 모두 헤더에 담겨있다.

엔티티 본문은 가공되어 있지 않은 데이터에 불과하기 때문에 헤더는 그 데이터의 의미에 대해 설명해야할 필요가 있다.

엔티티 본문은 무조건 빈 CRLF 줄 바로 다음부터 시작한다. 어떠한 언어든 상관없이 항상 CRLF바로 다음에 위치한다.

----

## Content-Length: 엔티티의 길이

Content-Length 헤더는 메시지의 본문의 크기를 바이트 단위로 나타낸다. 어떻게 인코딩 되었든 상관없이
크기를 표현할 수 있다. (gzip으로 압축하였다면 압축된 후의 크기를 나타낸다)

Content-Length는 청크 인코딩으로 전송하지 않는 이상 엔티티 본문을 포함한 메시지에서는 필수적으로 있어야한다.

Content-Length는 서버충돌로 인해 메시지가 잘렸는지 감지하고자 할때와, 지속적으로 커넥션을 공유하는 메시지를 올바르게
분할하고자 할 때 필요하다.

### 잘림 검출

옛날 버전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지하였으나 `Content-Length`가 없다면 클라이언트는
커넥션이 정상적으로 닫힌것인지 메시지 전송중에 충돌이 발생한것인지 구분하지 못한다. 따라서 클라이언트는 잘림검출하기위해
`Content-Length`를 필요로 한다.

메시지 잘림은 특히 캐시 프록시 서버에 특이 취약하다. 이유는 만약 캐시가 잘린 메시지를 수신했으나 잘렸다는것을
인지하지 못했다면 잘못된 콘텐츠를 계쏙 제공하게 된다. 그래서 보통 캐시 프록시 서버는 명시적으로 `Content-Length`헤더를
갖고 있자 않다면 캐시하지 않는다.

### 잘못된 Content-Length

`Content-Length`는 지속 커넥션을 위해서는 필수이다. 만약 응답이 지속 커넥션을 통해서 왔다면 그 뒤에 다른 응답이 올 것이다.

`Content-Length`는 클라이언트에게 메시지가 어디서 끝나고 다음 시작은 어디인지도 알려준다.
또한 `Content-Length` 없이는 커넥션이 지속적이기 때문에 클라이언트가 커넥션이 닫힌 위치를근거로 메시지의 끝을인식하는것은 불가능하다.

청크 인코딩은 데이터를 각각이 특정한 크기를 갖는 일련의 청크들로 쪼개어 보내기 때문에 엔티티 전체크기를 알 수 없다하더라도 서버는
청크 인코딩을 이용하여 엔티티를 잘 정의된 크기의 조각들로 전송할 수 있다.

### 콘텐츠 인코딩

HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록 엔티티 본문을 인코등하게 해준다.
만약 본문이 이미 인코딩 되어 있다면 `Content-Length`는 인코딩 된 본문의 길이를 바이트 단위로 정의한다.

### 엔티티 본문 길이 판별을 위 한 규칙

본문 길이 판별을 위한 규칙은 반드시 나열된 순서대로 적용되어야 한다.

1. 본문을 갖는 것이 허용되지 않는 특정타입의 HTTP 메시지에서는 본문 계산을 위한 Content-Length 헤더가 무시된다. 이경우 Content-Length헤더는
   부가정보에 불과하다. 엔티티 본문을 금하는 메시지는 어떤 엔티티 헤더 필드가 존재하느냐와 상관없이 반드시 헤더 이후의 첫번째 빈줄에서 끝나야 한다.

2. 메시지가 Transfer-Encoding 헤더를 포함하고 있다면 메시지가 커넥션이 닫혀서 먼저 끝나지 않은 이상
   엔티티는 0바이트 청크라 불리는 특별한 패턴으로 끝나야 한다.

3. 메시지가 Content-Length 헤더를 갖는다면 Transfer-Encoding 헤더가 존재하지 안흔 이상 본문의 길이를 담게 된다.
   만약 Content-Length 헤더 필드와 identity가 아닌 Transfer-Encoding헤더 필드를 갖고 있는 메시지를 받았다면
   반드시 Content-Length헤더를 무시해야 한다.

4. 메시지가 `multipart/byteranges`미디어 타입을 사용하고 엔티티 길이가 별도로 정의되지 않았다면 메시지의 각 부분은 각자가
   스스로의 크기를 정의한다.

5. 위 어떤 규칙도 해당하지 않는다면 엔티티는 커넥션이 닫힐 때 끝난다. 실질적으로 서버만이 메시지가 끝났음을 알리기위해서 커넥션을 닫을 수 있다.

6. HTTP/1.0과의 호환을 위해서 엔티티 본문을 갖고 있는 HTTP/1.1요청은 반드시 유요현 Content-Length헤더도 가지고 있어야 한다.

---

## 미디어 타입과 Charset

`Content-Type` 헤더는 본문의 MIME 타입을 기술한다. `MIME`타입은 전달되는 데이터 매체의 형식의 표준화된 이름이다.

클라이언트 애플리케이션은 콘텐츠를 적절히 해독하고 처리하기 위해 MIME 타입을 이용한다.

흔히 사용되는 MIME 타입은 아래와 같다.

- `text/html` : HTML 문서
- `text/plain` : 플레인 텍스트 문서
- `image/gif` : GIF 이미지
- `image/jpeg` : JPEG 이미지
- `audio/x-wav` : WAV음향 데이터
- `model/vrml` : 삼차원  VRML 모델
- `application/vnd.ms-pwerpoint` : 파워 포인트
- `multipart/byteranges` : 전체 문서의 특정 범위
- `message/http`: 완전한 HTTP 메시지
- `application/json` : JSON데이터

헤더가 본문의 미디어 타입을 명시한다는 것은 중요하다.

### 텍스트 매체를 위한 문자 인코딩

Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원한다. 예를들면
charset이 그 예디다

`Content-Type: text/html; charset=iso-8859-4`


### 멀티파트

멀티파트는 여러개의 메시지를 포함하며, 하나의 복합 메시지로 보내진다. 각 구성요소는 자족적으로 자신에 대해 서술하는 헤더를 포함한다.

여러 구성요소이 이어져 있고, 문자열 하나로 서로의 경계가 식별된다.

`Content-Type: ,multipart/form-data; boundary=[abcdefgawerwe]` 와 같이 구성 된다.
이때 boundary는 본문의 서로 다른 부분을 구분하기 위한 구분자로 사용된다.

---

## 콘텐츠 인코딩

HTTP 애플리케이션은 콘텐츠를 보내기전에 인코딩을 하려고 한다. 예를 들면 느린속도로 연결된 클라이언트에게
큰 HTML문서를 전송하기전에 서버는 전송시간을 줄이기 위해 압축을 하거나, 허가받지 않은 다른사람이 볼 수 없게
콘텐츠를 암호화 하거나 뒤섞어서 보낼 수 있다.

이러한 종류의 인코딩은 보내는 쪽에서 콘텐츠에 적용한다.

### 콘텐츠 인코딩 과정

1. 웹서버가 원본 Content-Type 과 Content-Length헤더를 수반한 원본 응답 메시지를 생성한다.
2. 콘텐츠 인코딩서버가 인코딩 된 메시지를 생성한다. 인코딩된 경우 Content-Type은 같지만 Content-Length는 다르다.
   Content-Encoding 헤더를 인코딩된 메시지에 추가하여 수신측에서 디코딩할 수 있게 한다.
3. 수신측에서는 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.

P406 참고

### 콘텐츠 인코딩 유형
> HTTP 는 몇가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는것도 허용한다.

- `gzip` : GNU zip 인코딩이 적용되었다.
- `compress` : 유닉스 파일 암축 프로그램인 compress가 실행되었다.
- `deflate` : zlib 포맷으로 압축
- `identity` : 어떠한 인코딩도 수행되지 않았음을 의미, Content-Encoding헤더가 존재하지 않는다면 identity값으로 간주

위의 인코딩 방식은 메시지의 크기를 손실없이 줄이기 위한 무손실 압축 알고리즘이다. 이중 gzip이 가장 효율적이고 널리 사용된다.

### Accept-Encoding 헤더

해당 헤더는 서버에게 클라이언트가 지원하는 인코딩의 목록을 해당 헤더를 통해 전송한다. 만약 해당 헤더를 포함하지 않는다면
서버에서는 클라이언트가 어떤 인코딩이든 받아들일 수 있는 준비가 되었다고 간주한다.

`Accept-Encoding: gzip`과 같이 사용할 수 있으며 q 속성을 통해 선호도를 나타낼 수 있다. q값의 범위는 선호하지 않음을 의미하는 0.0 부터 가장 선호한다는것을 나타내는
1.0까지이다.

---

## 전송 인코딩과 청크 인코딩

전송인코딩 또한 엔티티 본문에 적용되는 가역적 변환이지만 구조적인 이유 때문에 적용되는 것이며 콘텐츠의 포맷과는 독립적이다.

### 안전한 전송

전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 안전한 전송을 위해 존재하였다. HTTP에서 전송된 메시지으 본문이 문제를
발생시키는데는 몇가지 이유 밖에 없다.

1. 알 수 없는 크기
> 몇몇 게이트웨이 애플리케이션과 콘텐츠 인코더는 콘텐츠를 먼저 생성하지 않고서는 본문의 최종 크기를 판단할 수 없다.
> 흔히 사이즈를 알기 전에데이터의 전송을시작하려고 한다 그러면 HTTP는 Content-Length를 요구하기 때문에 데이터의 끝을 알리는 특별한 꼬리말을 포함시켜
> 전송 인코딩으로 데이터를 보내려고 시도한다.


2. 보안
> 공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용하여 알기 어렵게 섞어버린다.
> 다만 이미 SSL과 같은 전송계층보안방식이 있기 때문에 전송 인코딩 보안은 흔하지 않다.

---

### Transfer-Encoding 헤더

전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 `Transfer-Encoding`, `TE` 두개 뿐이다.

### `Transfer-Encoding`
안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 알려준다.

### `TE`
어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용한다.


모든 전송인코딩값은 대소문자가 구별된다. HTTP/1.1은 Transfer-Encoding과 TE 헤더 필드에 전송 인코딩 값을 사용한다.
최신 HTTP 명세는 오직 하나의 전송 인코딩, 즉 청크인코딩만을 정의했다.

`TE`헤더는 `Accept-Encoding`헤더와 마찬가지로 선호하는지 표현하는 Q값을 가질 수 있다.

다만 HTTP/1.1명세는 청크 인코딩에대해서 Q값이 0.0을 갖는것을 금지한다.

---

### 청크 인코딩

청크 인코딩은 메시지를 일정 크기의 청크 여러개로 쪼갠다. 서버는 각 청크를 순차적으로 보낸다.

청크 인코딩을 사용하게 되면 메시지를 보내기 전에 전체 크기를 알아야 할 필요가 없다.

본문이 동적으로 생성되고 일부를 버퍼에 담은 뒤 청크를 그것의 크기와 함께 보낸다. 따라서 본문 전체를 보낼때까지 해당 단계를 반복한다.


#### 청크와 지속 커넥션  