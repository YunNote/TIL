# 12. 최적화 및 일반화 회피

---

### 주요 내용 
 
- 일반성을 최소화하여 커플링 최소화
- 불변속성 측면에서 최적화 바라보기
- 최적화를 통해 취약성 관리하기


---

### 단순성 추구 


---


### 일반화의 시기와 방법

<br> 

### 🗯️ 구현의 최소화로 일반화 지양하기

> 복제, 변환, 통합의 3단계 방법은 기능이 최소한인 경우에만 최소한의 일반화를 보장한다.

`하지 않는 일의 양을 최대화 하라 - 켄트백`

무언가를 만들기 위해서는 먼저 컨텍스트, 즉 구현하려는 동작의 범위를 이해해야한다.

정확하게 이해하지 못한부분이 생긴다면 우리는 빠짐없이 다룰 필요가 있다고 가정하게 되는 경향이 있다.
또한 사용자 or 고객에게 더 많은 것을 해결하는 기능을 주는 것이 잘하는 것이라고 생각하게 된다.

> 해당 내용에서 말하는 일반화는 특정한 상황이나 입력값에 종속적이지 않고 다양한 상황에서 동작할 수 있는 코드를 의미합니다.

일반화를 수용하도록 코드를 설계하는것은 코드의 재사용성과 유지 보수성을 향상시켜 버그를 줄일수도 있다.

하지만 너무 많은 일반화는 부담이 될 수 있다. 이유는 
너무 많은 일반화를 해버리게 되면 코드가 복잡해지고 이해하기 어려워질 수 있으며, 개발 시간도 복잡성이 증가함에 따라 비례하게 증가하기 때문이다.

이에 따라 해당 도서에서는 보수적으로 요구된 대로만 구축하는 이유에 대해 설명을 한다.

보수적으로 요구사항만 구축하는 이유는 소프트웨어가 발전함에 따라 요구사항도 끊임없이 변경이 되기 때문이다.
이러한 변경으로 인해 시간을 들여 개발한 일반화된 코드는 오히려 사용하지 못할수도있어 모든 노력이 쉽게 무효화 된다.

따라서 상상할 수 있는 문제가 아닌 이미 당면한 문제만 해결해야 한다.

---

### 🗯️ 안정성이 유사한 것 통합하기

해당 도서에서 글쓴이의 실제 경험담이 나오게 되는데. 초기설계와 기능작업을 마친 후 데이터를 사용하여
흥미진진한 경기를 할 팀을 만들 수 있을것을 깨닫고 사용자가 항상 사용할 기능이라 생각하고 구현하였으나, 이미
매치업을 결정하는 방법이 있었기 때문에 해당 기능이 필요하지 않았고 몇번 사용된것이 전부였다 라는 경험담이 나옵니다.

위 경험담을 바탕으로 보았을때 해당 기능을 구현하기 위해 기존 코드에 일부 지원 기능과 코드를 일반화 하게되었다면 
일반화를 없애기가 더 어렵게 되고, 인지비용을 부풀리기 때문에 반드시 제거를 해야만했다.

해당 내용을 바탕으로 보았을때 이 문제를 피하기 위해서는 통합할 때 주의해야 한다. 경험상 새로운 것과 
오래된 것을 바로 통합하지 않는것이 좋다, 다만 통합 대상이 비슷한 안정성에 도달할때까지 기다려라, 일반적으로 
버전이 새로 나올수록 안정화는 빨리 된다.

---

### 🗯️ 불필요한 일반화 제거

불필요한 일반화를 제거하는 마지막 무기는 우리가 정기적으로 모니터링을 통해 사용하지 않는 일반화된 코드에 대해서
삭제하는 것이다.

원하지 않는 일반화를 제거하기 위해서는 앞선 4장에 등장한 `메서드 전문화`와 `삭제 후 컴파일하기` 리팩터링 패턴을 사용할 수 있다.

다만 `삭제 후 컴파일하기`의 경우에는 제거할 수 있는 모든 일반화를 찾지 못할 수 있다.


불필요한 일반화를 찾는 효과적인 방법은 함수에 전달되는 런타입 인자들을 모니터링하는 방법이 있다.
객체를 합리적으로 직렬화 할 수 있다면 매개변수를 기록하는 코드를 추가한 다음 각 메서드의 최신 N개의 호출을 검사하고
일부 매개변수가 항상 동일한 값으로 호출되는지 확인하며, 이 경우 매개변수에 따라 `메서드 전문화`를 적용할 수 있다.

다른 값으로 각각 호출되더라도 특수한 복사본을 만드는 것이 더 가치 있을 수 있다.

> 메서드 전문화?
> 
> 특정 상황 또는 조건에 대해 특별히 처리되도록 디자인되거나 구현된 메서드를 의미하며, 다형성의 한 형태로 생각하면 됩니다.


---

### 최적화 시기와 방법

> 높은 인지부하의 또 다른 일반적인 방법은 최적화이며, 일반화와 마찬가지로 어떤 일을 하기전에 필요성이 납득되어야 한다.
> <br>
> 최적화가 필요한 이유를 찾기위해서는 자동 성능 테스트를 설정하고 테스트가 실패할때만 최적화 하는것이 좋다.
> 
> 가장 일반적인 방법으로는 다음과 같은것이 있다.
> 
> 1. `벤치마크 테스트` - ex) 해당 메서드는 14ms 안에 종료되어야 한다
> 2. `부하 테스트` - ex) 초당 1000개의 요청을 처리할수 있어야한다
> 3. `성능 승인 테스트` - ex) 마지막으로 실행했을때보다 10%이상 느려지면 안된다.





