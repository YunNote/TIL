# 12. 최적화 및 일반화 회피

---

### 주요 내용 
 
- 일반성을 최소화하여 커플링 최소화
- 불변속성 측면에서 최적화 바라보기
- 최적화를 통해 취약성 관리하기


---

### 단순성 추구 


---


### 일반화의 시기와 방법

<br> 

### 🗯️ 구현의 최소화로 일반화 지양하기

> 복제, 변환, 통합의 3단계 방법은 기능이 최소한인 경우에만 최소한의 일반화를 보장한다.

`하지 않는 일의 양을 최대화 하라 - 켄트백`

무언가를 만들기 위해서는 먼저 컨텍스트, 즉 구현하려는 동작의 범위를 이해해야한다.

정확하게 이해하지 못한부분이 생긴다면 우리는 빠짐없이 다룰 필요가 있다고 가정하게 되는 경향이 있다.
또한 사용자 or 고객에게 더 많은 것을 해결하는 기능을 주는 것이 잘하는 것이라고 생각하게 된다.

> 해당 내용에서 말하는 일반화는 특정한 상황이나 입력값에 종속적이지 않고 다양한 상황에서 동작할 수 있는 코드를 의미합니다.

일반화를 수용하도록 코드를 설계하는것은 코드의 재사용성과 유지 보수성을 향상시켜 버그를 줄일수도 있다.

하지만 너무 많은 일반화는 부담이 될 수 있다. 이유는 
너무 많은 일반화를 해버리게 되면 코드가 복잡해지고 이해하기 어려워질 수 있으며, 개발 시간도 복잡성이 증가함에 따라 비례하게 증가하기 때문이다.

이에 따라 해당 도서에서는 보수적으로 요구된 대로만 구축하는 이유에 대해 설명을 한다.

보수적으로 요구사항만 구축하는 이유는 소프트웨어가 발전함에 따라 요구사항도 끊임없이 변경이 되기 때문이다.
이러한 변경으로 인해 시간을 들여 개발한 일반화된 코드는 오히려 사용하지 못할수도있어 모든 노력이 쉽게 무효화 된다.

따라서 상상할 수 있는 문제가 아닌 이미 당면한 문제만 해결해야 한다.

---

### 🗯️ 안정성이 유사한 것 통합하기

해당 도서에서 글쓴이의 실제 경험담이 나오게 되는데. 초기설계와 기능작업을 마친 후 데이터를 사용하여
흥미진진한 경기를 할 팀을 만들 수 있을것을 깨닫고 사용자가 항상 사용할 기능이라 생각하고 구현하였으나, 이미
매치업을 결정하는 방법이 있었기 때문에 해당 기능이 필요하지 않았고 몇번 사용된것이 전부였다 라는 경험담이 나옵니다.

위 경험담을 바탕으로 보았을때 해당 기능을 구현하기 위해 기존 코드에 일부 지원 기능과 코드를 일반화 하게되었다면 
일반화를 없애기가 더 어렵게 되고, 인지비용을 부풀리기 때문에 반드시 제거를 해야만했다.

해당 내용을 바탕으로 보았을때 이 문제를 피하기 위해서는 통합할 때 주의해야 한다. 경험상 새로운 것과 
오래된 것을 바로 통합하지 않는것이 좋다, 다만 통합 대상이 비슷한 안정성에 도달할때까지 기다려라, 일반적으로 
버전이 새로 나올수록 안정화는 빨리 된다.

---

### 🗯️ 불필요한 일반화 제거

불필요한 일반화를 제거하는 마지막 무기는 우리가 정기적으로 모니터링을 통해 사용하지 않는 일반화된 코드에 대해서
삭제하는 것이다.

원하지 않는 일반화를 제거하기 위해서는 앞선 4장에 등장한 `메서드 전문화`와 `삭제 후 컴파일하기` 리팩터링 패턴을 사용할 수 있다.

다만 `삭제 후 컴파일하기`의 경우에는 제거할 수 있는 모든 일반화를 찾지 못할 수 있다.


불필요한 일반화를 찾는 효과적인 방법은 함수에 전달되는 런타입 인자들을 모니터링하는 방법이 있다.
객체를 합리적으로 직렬화 할 수 있다면 매개변수를 기록하는 코드를 추가한 다음 각 메서드의 최신 N개의 호출을 검사하고
일부 매개변수가 항상 동일한 값으로 호출되는지 확인하며, 이 경우 매개변수에 따라 `메서드 전문화`를 적용할 수 있다.

다른 값으로 각각 호출되더라도 특수한 복사본을 만드는 것이 더 가치 있을 수 있다.

> 메서드 전문화?
> 
> 특정 상황 또는 조건에 대해 특별히 처리되도록 디자인되거나 구현된 메서드를 의미하며, 다형성의 한 형태로 생각하면 됩니다.


---

### 최적화 시기와 방법

> 높은 인지부하의 또 다른 일반적인 방법은 최적화이며, 일반화와 마찬가지로 어떤 일을 하기전에 필요성이 납득되어야 한다.
> <br>
> 최적화가 필요한 이유를 찾기위해서는 자동 성능 테스트를 설정하고 테스트가 실패할때만 최적화 하는것이 좋다.
> 
> 가장 일반적인 방법으로는 다음과 같은것이 있다.
> 
> 1. `벤치마크 테스트` - ex) 해당 메서드는 14ms 안에 종료되어야 한다
> 2. `부하 테스트` - ex) 초당 1000개의 요청을 처리할수 있어야한다
> 3. `성능 승인 테스트` - ex) 마지막으로 실행했을때보다 10%이상 느려지면 안된다.

`테스트에서 최적화가 필요하다는것이 입증되면 이후 유지보수하여 인지화 부담을 최소화 하는 방법으로 진행해야한다.`

---

### 최적화 전 리팩터링

최적화를 진행하기전 코드가 적절하게 리팩터링이 진행되었는지 확인해야 한다. 리팩터링의 목표중 하나는 불변속성을 지역화해서
명확하게 만드는것이 좋다. 잘 분해된 코드는 최적화가 더 쉽다.

#### 컴파일러에게 맡기기

코드를 좋게 만드는 또 다른 이유는 컴파일러가 더 나은 코드를 생성하도록 지속적으로 돕기 때문이다.

앞선 1장의 예에서 좋은 컴파일러는 부작용이 없다고 판단되면 반복되는 하위 표현을 자동으로 제거할 수 있다라고 나와있습니다.

```java
// 변경 전 
return pow(base, exp / 2) * pow(base, exp / 2);

// 최적화 됨
let result = pow(base, epx / 2);
return result * result;
```

리팩터링 및 코드개선을 할때 주의해야할 점은 내가 특이한 패턴과 해결책을 통해 창의성을 입증함으로써 똑똑해 보이려는 사람들의 욕망을 주의해야한다.

```java

// 관용적인 표현 
function half(n : number) {
   return n / 2;   
}

// 과시적인 표현
function half(n : number) {
   return n >> 1
}

```

과시용 코드는 일반적으로 보기거 너무 어렵다, 관용적인 표현으로 구성된 코드는 일반적이어서 무든주류 컴파일러에서 자동으로 최적화를 수행한다.

---

### 제약 이론에 따른 최적화 

위 첫번쨰 내용처럼 코드 리팩터링을 진행하였음에도 테스트가 만족스럽지 않다면 다시한번 최적화 하는 작업을 해야한다.

검색해보니 제약이론의 특징으로는 `목표와 제약`, `자원의 제한` 등이 대표적으로 있습니다.

`목표와 제약` - 어떤 목표를 달성하려고 할 때, 주어진 제약 조건을 고려하여 최적의 방법을 찾는 방법론. 
`자원의 제한` - 자원이 제한적인 상황에서 작업을 수행할 때 특히 유용하다. 어떻게 자원을 효율적으로 할당하고 최적의 일정을 계획할지 결정하는데 도움을 준다.

자원의 제한의 한 예로는 다운스트림 작업자가 이전 병목 현상의 증가된 처리량을 따라가지 못하거나, 업스트림 작업자가 이전 병목 현상때만큼 출력을 빠르게
생성하지 못할 수 있다.

이러한 경우에 해결하기 위한 `리소스 풀링`이라는 해결책이 있다.

### `리소스 풀링`
> 우리가 흔히 개발 및 운영에서 자주 사용되는 개념 
> 흔히 우리가 부르는 커넥션풀과 동일한 내용이라고 봐도 무방해 보입니다.<br>
> 
> 사용 가능한 모든 리소스를 필요할 때 사용할 수 있는 공용풀에 배치하는것을 의미한다.
> 
> `리소스 풀링`의 주요 아이디어는 다음과 같다.                                                                     
>  - 자원 관리 : 사전에 생성하고 풀에 저장하며, 필요시에 꺼내어 사용한다.
>  - 재사용 : 자원을 사용한 후 파괴하지 않고 반드시 다시 풀에 반환한다. 재사용이 가능하기 때문에 오버헤드를 줄일 수 있다.
>  - 최적 활용 : 필요한 순간에만 사용 가능한 자원을 제공하여 최적화된 방식으로 시스템 자원을 사용할 수 있다.
>  <br><br>
> 이러한 리소스 풀링을 사용하면 시스템이 자동으로 처리해주기 때문에 우리가 스레드 구성에 대해 생각할 필요가 없지만, 리소스 풀을 관리하기 위한 시스템의 인지비용은 증가하지만 단계에서 도메인
> 코드의 인지 비용에는 영향을 주지 않는다.

---

### 측정 지표를 사용한 최적화 

코드 개선도 했고, 리소스 풀링도 했지만 그래도 성능 요구사항을 충족하지 못했다면 병목이 걸리는 지점 내에서 최적화를 진행해야 한다.

> 해당 내용에서는 싱글 스레드상황에 놓여있고, 하나의 스레드가 더 빠르게 종료되어야 한다는 가정으로 설명합니다.

모든 것을 최적화 할수는 없다, 따라서 가장 중요한 영향을 미치는 부분의 코드에 노력을 집중하면 좋다.

위와 같은 방식으로 최적화를 하기 위해서는 코드에서 `핫스팟`을 식별해야 합니다. `핫스팟` 이라는 것은 스레드가 대부분의
시간을 보내는 지점을 의미합니다. 

메서드가 핫스팟이 되는 두가지 요인은 다음과 같다. 

 - 완료까지 시간이 걸리는 메서드
 - 루프 내부에 있는 메서드

`프로파일링`이란 메서드에서 얼마나 많은 누적 시간을 소모했는지 추적하는것을 의미한다. `프로파일링`을 지원하는 도구는 많지만 다른 방법으로
최상위 수준에서 시작해서 수동으로 소요 시간을 측정하는 코드를 추가한 후, 전체 코드의 20% 80%의 시간을 차지하는 지점을 반복해서
드릴다운하는 것이 간편하다. [80:20 법칙](https://asana.com/ko/resources/pareto-principle-80-20-rule)

---

### 좋은 알고리즘과 데이터 구조 선택하기

`핫스팟`을 찾았다면 이를 최적화 하는 방법을 생각해야 한다. 가장 안전한 최적화방법으로는 하나의 데이터 구조를 동등한
인터페이스를 가진 다른 데이터 구조로 변경하는 것이다. 이 최적화는 새로운 데이터 구조에 적응하기 위해
도메인 관련된 코드를 변경할 필요가 없어 안전하다.

만약 개발자가 기존 데이터 구조 or 알고리즘 중에서 선택을 해야할 경우에는 해당 동작을 살펴보는것이 제일 좋고 만약 직접 구현을 해야하는 경우라면
핫스팟에 있지 않는 부분이라면구현의 용이성을 먼저 생각해야한다.

---

### 캐시 사용하기 

우리가 가장 많이 사용하는 최적화는 `캐시`입니다. 

캐시는 매번 계산을 수행하는게 아니라 한번 계산된 정보를 임시 저장소에 저장하고 재사용 하는것을 의미한다.

캐시는 멱등 불변속성과 조합할 때 가장 안전합니다.
만약 멱등성이 일시적인 경우에는 비교적 덜 안전하게 됩니다. 예를들면 캐시되는 동안 가격이 변경되면 캐시값이 올바르지 않아 바로 에러로 이어질 수 있기 때문입니다.

---

### 최적화된 코드 분리하기

위에 나온 방법인 알고리즘, 동시성 및 캐시로 성능 테스트를 만족시키는데 불충분한 경우는 거의 없다. 만약 불충분한 경우가 생긴다면
마이크로 최적화라고도 하는 성능 튜닝으로 전환한다.

`마이크로 최적화`는 성능 향상을위해 작은 규모의 최적화 작업을 의미, 개별 코드라인, 함수 또는 루프 내부에서 수행하게 된다.

#### 잠금 영역 최소화를 위한 메서드와 클래스 사용

일반적으로 까다로운(인지 비용이 많이드는) 함수들은 이해하지 않고서는 크게 변경하기는 어렵다, 따라서 해당 코드는 기본적으로 잠겨있다. 따라서 튜닝된 코드는 격리하여야 한다.
튜닝이 효과를 발휘하기 위해서는 잠가야 하는 코드의 양을 최소화 해야합니다. 또한 데이터들을 별도의 메서드로 추출하면서 명명을 잘 지어야 한다. 그러면 나중에 언제든지 고칠 수 있으며, 문서화되어 추후에 누구도 소스를 뒤질 필요 없이
이름을 통해 유추할 수 있다.


---

요약

 - 단순화는 코드가 요구하는 인지부하를 줄이는 것이다.
 - 일반화는 코드간의 결합도가 높아져 변경에 어려움이 따른다.
 - 최소한의 구현으로 조합된 통합을 통해 일반화를 도입함으로써 불필요한 일반화를 도입하지 않도록 한다.
 - 불필요한 일반화를 발견하거나 최적화할 후보들을 찾을떄는 모니터링 및 프로파일링을 사용한다.
 - 모든 최적화는 보통 성능 테스트의 일부 지침에 따른 근거가 제시되어야 한다. 일상 업무에 최적화 하는것은 피해야 한다.
 - 리펙터링은 불변속성을 지역화한다. 최적화는 불변속성에 의존합니다. 따라서 최적화 하기전에 리팩터링을 먼저 하는것이 좋다.
 - 리소스 풀링은 도메인과 관련된 코드의 취약성을 높이지 않고 최적화 할 수 있다.
   주로 리소스 관리 재사용과 관련된 부분에 적용되기 때문에 서비스 호출 및 데이터 베이스와 같은 I/O작업과 관련이 있기 때문에 도메인과 관련된 비즈니스 로직이나 핵심 로직 부분에는 영향을 주지 않는다.
 - 최적화 시 대상으로 기존 알고리즘과 데이터 구조중에서 하나를 선택하는 것이 좋다.
 - 캐시는 불변속성이 거의 없는 저렴하고 안전한 최적화가 될 수 있다.
 - 성능 튜닝을 사용할 때는 사람들이 파악하는데 시간을 낭비하지 않도록 튜닝된 코드를 격리한다.
