## 4. 타입 코드 처리하기


### 규칙 : if 에서 else를 사용하지 말것

정의 - 프로그램에서 이해하지 못하는 타입인지를 검사하지 않는 한 if 문에서 else를 사용하지 마라.

if-else를 사용하면 코드에서 결정이 내려지는 지즘을 고정하게 된다. 그럴 경우 if-else가 있는
위치 이후에서는 다른 변형을 도입할 수 없기 때문에 코드의 유연성이 떨어지게 된다.

결과적으로 `if-else`는 하드코딩된 결정으로 볼 수 있다. 코딩에서 하드코딩된 상수가 좋지 않은것처럼
하드코딩된 결정또한 좋지 않다.

이러한 상황으로 보면 하드코딩은 하지 않는것이 좋은데, `if`와 함께 `else`를 함께 사용하지 않는것이다.

주로 코드작성시 독립된 if문은 검사로 간주하고, if-else문은 의사결정으로 간주한다.

우리는 구현을 알기 때문에 아래 코드가 이해가 되지만 사용자에게는 도움이 되지 않아 다음과 같이 이해할 수 있는
오류를 발생시킨다.

```typescript
// 변경 전
function average(ar: number[]) {
  if(size(ar) === 0) {
    throw "Empty array not allowed";
  }else {
    return sum(ar) / size(ar);
  }
}
```

```typescript
// 변경 후 
function assertNotEmpty(ar: number[]) {
  if(siez(ar) === 0) {
    throw "Empty array not allowed";
  }
}

function average(ar: number[]) {
  assertNotEmpty(ar);
  return sum(ar) / size(ar);
}

```

---

#### 스멜 

해당 규칙은 스멜로 인식되는 `이른 바인딩(early binding)`과 관련 있다.
프로그램을 컴파일할 때 `if-else`같은 의사결정 동작은 컴파일 시 처리되어 애플리케이션에 고정되며 재컴파일 없이는
수정할 수 없다. `이른 바인딩(early binding)`의 반대는 코드가 실행되는 순간에 동작이 결정되는 `늦은 바인딩(late binding)`이다.

이른 바인딩은 if문을 수정해야 변경할 수 있기 때문에 추가에 의한 변경을 방해한다. 늦은 바인딩은 추가를 통한
변경을 가능하게 한다.

---

#### 의도

if는 조건 연산자로 흐름을 제어한다. 이것은 다음에 실행할 코드를 결정 한다는것을 의미한다.
하지만 객체지향 프로그래밍에는 인터페이스를 사용하여 두가지 다른구현이 있는 경우 인스턴스화하는 클래스에따라 실행할
코드를 선택할 수 있다. 이는 더 강력하고 유연한 도구인 객체를 사용하는 방안을 찾게한다.

---

#### 참조

챕터 5장에서 다룬다.

---

### 규칙 적용
> 일터페이스로 변경하여 값들을 클래스로 바꾼다, 값이 객체가 되었기 때문에 
> if 구문 내의 코드를 각 클래스의 메서드로 옮긴다.

---

### 리팩터링 패턴 : 클래스로 타입 코드 대체 

> 리팩터링 패턴은 열거형을 인터페이스로 변환하고 열거형의 값들은 클래스가 된다. 그렇게 하면 각 값에 속성을 추가하고 해당
> 특정 값과 관련된 기능을 특성에 맞게 만들 수 있다.
> 
> 열거형의 값을 클래스로 변환할 때는 다른 열거 값을 고려하지 않고도 해당 값과 관련된 기능을 그룹화 할 수 있다.
> 
> 열거형인 상태에서 새로운 값을 추가하는 것은 수많은 파일에 걸쳐서 열거형과 연결된 로직들을 수정해야 하지만
> 인터페이스로 구현한 새로운 클래스를 추가하는 것은 해당 클래스에 메서드의 구현이 필요하기만할뿐 다른 클래스들을 수정할 필요가 없다.
> 

타입 코드 또한 열거형이 아닌 enum을 사용한 형태로 변경하는것이 더 좋다.
```typescript
// 변경 전
const SMALL = 33;
const MEDIUM = 37;
const LARGE = 42;

// 변경 후
enum Sizes{
  SMALL = 33,
  MEDUIM = 37,
  LARGE = 42
}
```

---

### 클래스로 코드 이관하기

interface의 메서드를 선언하고 해당 interface를 구현하는 클래스들을 만들고 전달받은 객체를통해
구현된 메서드를 실행한다.

다음과 같이 구현하면 체계적이기 떄문에 적은 인지 부하로 수행할 수 있으면서 결과적으로는 매우 좋은 코드가 만들어진다.

해당 리팩터링 패턴을 사용하면 if 구문이 제거되고 기능이 데이터에 더 가까이 이동된다.
특정 값에 대한 기능이 값에 해당하는 클래스로 이ㅏ동하기때문에 이는 불변속성을 지역화 하는데 큰 도움을 준다.

---

### 불필요한 메서드 인라인화 

```typescript

// 변경 전 
function handleInput(input: input) {
  input.handle();
}

handleInput(current)

// 변경 후 
current.handle();
```

다음과 같이 기존에 한줄로 구현된 코드를 오히려 인라인화를 통해 위와 같이 표기가능하며 정확히 메서드 추출과는 반대입니다.

---

### 리팩터링 패턴 : 메서드와 인라인화 

해당 리팩터링 패턴은 코드 제거의 주제를 지향한다. 즉 더 이상 가독성에 도움이 되지 않는 메서드를
제거한다. 그 방법은 호출하는 모든 곳으로 코드를 옮기는 것이다. 이렇게 하면
메소드가 사용되지 않아 안전하게 삭제할 수 있다.

> 메서드의 인라인화 리팩터링 패턴과 메서드를 인라인으로 사용하는 것은 다르다.

메서드의 인라인화를 수행할 때는 모든 호출 측을 수정하여 원래의 메서드를 제거한다.

해당 내용에서는 메서드가 한줄만 있는 경우 해당 작업을 수행한다.

이것은 엄격한 다섯 줄 제한 규칙떄문인데 한줄인 메서드를 인라인화 하면 이 규칙을 위반하지 않는다.

다만 다음과 같은 예는 한줄이지만 목적을 위해 메서드로 존재하는 것이 가독성에 도움이 되기 때문에 이것을 인라인화 해서는 안된다. 이는 호출 또는 전달, 한가지만 할 것 규칙을 적용해야 하는 이유가 된다
```typescript

const NUMBER_BITS = 32;
function absolute(x: number) {
  return (x ^ x >> NUMBER_BITS - 1) - (x >> NUMBER_BITS -1);
}
```

해당 도서 P.73 예제 4.60 에서 해당 관련 예제가 있는데 코드 복제가 단순히 좋은 생각인지 아닌지는
논란의 여지가 있다. (상세 내용은 6장 참고)

---

### 긴 if 문의 리펙터링

#### 일반성 제거 

P.78 예제 4.71

너무 일반적인 경우 유연성이 떨어지고 변경하기 어렵게 만든다
따라서 타입을 더 특정해야 한다.

#### 리팩터링 패턴 : 메서드 전문화

> 프로그래머들은 일반화하고 재사용 하려는 본능적인 욕구가 있지만 그렇게 하면 책임이 흐려지고 다양한 위치에서
> 코드를 호출할 수 있기때문에 문제가 될 수 있다. 해당 패턴은 이 효과를 발전시킨다, 
> 전문화된 메서드는 더 적은 위치에서 호출되어 필요성이 없어지면 더 발리 제거할 수 있다.

메서드 전문화를 하기위해서는 4가지의 절차를 따른다
1. 전문화하려는 메서드를 복제한다.
2. 메서드 중 하나의 이름을 새로 사용할 메서드의 이름으로 변경하고 전문화 하려는 매개변수를 제거한다.
3. 매개변수 제거에 따라 메서드를 수정해서 오류가 없도록 한다
4. 이전 호출을 새로운 것을 사용하도록 변경한다


#### switch가 허용되는 유일한 경로 
열거형 타입에 따른 경우의수가 많은경우 사용하는듯. (P.84 참고)

#### 규칙 : switch를 사용하지 말 것 
> default 케이스가 없고 모든 case에 대해서 반환값이 있는경우가 아니라면 switch를 사용하지 마라.

switch는 버그로 이어지는 두 가지 편의성을 허용하기 때문에 문제가 많다. 
1. switch로 case를 분석할 때 모든 값에 대한 처리를 실행할 필요가 없다. 이를 위해 default 키워드를 지원하고, 해당 키워드는 중복 없이 여러 값을 지정할 수 있다.
다만 새로운 속성이 추가하거나 할때 여전히 유효한지 컴파일러를 통해 판단할 수 없다. 
2. break키워드를 만나기 전까지 케이스를 연속해서 실행하는 플스루 로직이라는 점이다. break키워드를 누락하고 알아채지 못하면 폴 스루가 발생하여 문제가 생길 수 있따.

이러한 문제를 해결하기 위해서는 기능에 default를 두지 않는법도 있으며, break대신 return을 지정해서 폴스루 문제를 해결할 수 있다.
결과적으로 이러한 방법때문에 지양하는것이 좋다.

