## 4. 타입 코드 처리하기


### 규칙 : if 에서 else를 사용하지 말것

정의 - 프로그램에서 이해하지 못하는 타입인지를 검사하지 않는 한 if 문에서 else를 사용하지 마라.

if-else를 사용하면 코드에서 결정이 내려지는 지즘을 고정하게 된다. 그럴 경우 if-else가 있는
위치 이후에서는 다른 변형을 도입할 수 없기 때문에 코드의 유연성이 떨어지게 된다.

결과적으로 `if-else`는 하드코딩된 결정으로 볼 수 있다. 코딩에서 하드코딩된 상수가 좋지 않은것처럼
하드코딩된 결정또한 좋지 않다.

이러한 상황으로 보면 하드코딩은 하지 않는것이 좋은데, `if`와 함께 `else`를 함께 사용하지 않는것이다.

주로 코드작성시 독립된 if문은 검사로 간주하고, if-else문은 의사결정으로 간주한다.

우리는 구현을 알기 때문에 아래 코드가 이해가 되지만 사용자에게는 도움이 되지 않아 다음과 같이 이해할 수 있는
오류를 발생시킨다.

```typescript
// 변경 전
function average(ar: number[]) {
  if(size(ar) === 0) {
    throw "Empty array not allowed";
  }else {
    return sum(ar) / size(ar);
  }
}
```

```typescript
// 변경 후 
function assertNotEmpty(ar: number[]) {
  if(siez(ar) === 0) {
    throw "Empty array not allowed";
  }
}

function average(ar: number[]) {
  assertNotEmpty(ar);
  return sum(ar) / size(ar);
}

```

---

#### 스멜 

해당 규칙은 스멜로 인식되는 `이른 바인딩(early binding)`과 관련 있다.
프로그램을 컴파일할 때 `if-else`같은 의사결정 동작은 컴파일 시 처리되어 애플리케이션에 고정되며 재컴파일 없이는
수정할 수 없다. `이른 바인딩(early binding)`의 반대는 코드가 실행되는 순간에 동작이 결정되는 `늦은 바인딩(late binding)`이다.

이른 바인딩은 if문을 수정해야 변경할 수 있기 때문에 추가에 의한 변경을 방해한다. 늦은 바인딩은 추가를 통한
변경을 가능하게 한다.

---

#### 의도

if는 조건 연산자로 흐름을 제어한다. 이것은 다음에 실행할 코드를 결정 한다는것을 의미한다.
하지만 객체지향 프로그래밍에는 인터페이스를 사용하여 두가지 다른구현이 있는 경우 인스턴스화하는 클래스에따라 실행할
코드를 선택할 수 있다. 이는 더 강력하고 유연한 도구인 객체를 사용하는 방안을 찾게한다.

---

#### 참조

챕터 5장에서 다룬다.

---

### 규칙 적용
> 일터페이스로 변경하여 값들을 클래스로 바꾼다, 값이 객체가 되었기 때문에 
> if 구문 내의 코드를 각 클래스의 메서드로 옮긴다.

---

### 리팩터링 패턴 : 클래스로 타입 코드 대체 

> 리팩터링 패턴은 열거형을 인터페이스로 변환하고 열거형의 값들은 클래스가 된다. 그렇게 하면 각 값에 속성을 추가하고 해당
> 특정 값과 관련된 기능을 특성에 맞게 만들 수 있다.
> 
> 열거형의 값을 클래스로 변환할 때는 다른 열거 값을 고려하지 않고도 해당 값과 관련된 기능을 그룹화 할 수 있다.
> 
> 열거형인 상태에서 새로운 값을 추가하는 것은 수많은 파일에 걸쳐서 열거형과 연결된 로직들을 수정해야 하지만
> 인터페이스로 구현한 새로운 클래스를 추가하는 것은 해당 클래스에 메서드의 구현이 필요하기만할뿐 다른 클래스들을 수정할 필요가 없다.
> 

타입 코드 또한 열거형이 아닌 enum을 사용한 형태로 변경하는것이 더 좋다.
```typescript
// 변경 전
const SMALL = 33;
const MEDIUM = 37;
const LARGE = 42;

// 변경 후
enum Sizes{
  SMALL = 33,
  MEDUIM = 37,
  LARGE = 42
}
```

---

### 클래스로 코드 이관하기

interface의 메서드를 선언하고 해당 interface를 구현하는 클래스들을 만들고 전달받은 객체를통해
구현된 메서드를 실행한다.

다음과 같이 구현하면 체계적이기 떄문에 적은 인지 부하로 수행할 수 있으면서 결과적으로는 매우 좋은 코드가 만들어진다.

해당 리팩터링 패턴을 사용하면 if 구문이 제거되고 기능이 데이터에 더 가까이 이동된다.
특정 값에 대한 기능이 값에 해당하는 클래스로 이ㅏ동하기때문에 이는 불변속성을 지역화 하는데 큰 도움을 준다.

---

### 불필요한 메서드 인라인화 

```typescript

// 변경 전 
function handleInput(input: input) {
  input.handle();
}

handleInput(current)

// 변경 후 
current.handle();
```

다음과 같이 기존에 한줄로 구현된 코드를 오히려 인라인화를 통해 위와 같이 표기가능하며 정확히 메서드 추출과는 반대입니다.

---

### 리팩터링 패턴 : 메서드와 인라인화 
