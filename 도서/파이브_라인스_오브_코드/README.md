## 1. 리펙토링

---

> 1. 가장 단순한 설명으로 리펙토링은 `기능을 변경하지 않고 코드를 변경하는 것`<br>
> 2. 사람이 읽기 쉽고, 유지보수가 용이하며, 의도한 대로 잘 동작하게하기 위해


리펙토링을 하는 이유 

 - 코드개선을 통해 더 빠르게 만들기 위해
 - 더 작은 코드를 만들기 위해
 - 코드를 재사용 가능하게 하기 위해
 - 가독성을 높이고 유지보수를 용이하게 하기 위해

---


리펙터링은 코드스멜을 제거하는거 부터 시작하며, 리펙터링은 정기적으로 수정하는것이 효과적이고
비용이 적게 들기 때문에 가능하면 일상 업무에 통합하는 것이 좋다.

---


#### 레거시 시스템에서의 리팩터링

켄트 벡 - `우선 변경하기 쉽게 만든 후 변경하라`. 새로운 것을 구현할 때 새 코드를 쉽게
추가할 수 있게 리펙터링을 먼저 한다.

#### 언제 리펙터링을 해야 하지 말아야 할까?

리팩터링은 분명히 유익하지만 단점도 있다.

 - 한 번 실행하고 삭제할 코드(스파이크성)
 - 폐기되기 전 유지보수 모드에 있는 코드
 - 임베디드 시스템이나 게임의 고급 물리엔진과 같이 엄격한 성능 요구사항이 있는 코드

위 세가지 외에는 모든 경우 리팩터링에 투자하는것이 좋다.


---

1장에서나온 내용을 요악하면 다음과 같다.

1. 리팩터링을 수행하려면 식별하는 스킬과 단계를 명시적으로 가진 문화, 도구(IDE)의 조합이 필요.
2. 자동화된 테스트와 리팩터링을 별도로 학습하면 진입장벽을 낮출 수 있다. 자동화된 테스트 대신 컴파일러, 버전관리및 수동 테스트를 사용한다.
3. 탐색, 명세화, 구현, 테스트, 리팩터링, 전달을 사용하거나 코드를 변경하기 직전에 리팩터링을 수행하도록 권장.


---


## 2. 리팩터링 깊게 들여다보기


### 가독성 및 유지보수성 향상 

`더 나은 코드를 만드는 것` , `코드가 하는 일을 변경하지 않는것`에 초점을 두고 살펴본다.



### 가독성
> 가독성은 의도를 전달하기 위한 코드의 성질이다. 이말은 코드가 의도한 대로 작동한다는 가정하에
> 코드가 무슨일을 하는지 파악하기 매우 쉽다는 내용이다.

코드에서 가독성을 전달하는 방법에는 여러가지가 있다. 
 - 코드의 컨벤션을 따르는것
 - 주석
 - 변수 메서드 클래스 및 파일이름 지정
 - 공백사용 등등이 있다.


### 유지 보수성 
> 유지 보수성은 얼마나 많은 후보를 조사해야  하는지를 나타내는 표현이다.

읽고 살펴봐야 할 코드가 많을수록 시간이 더 오래걸리고 무언가를 놓칠 가능성이 높다.
따라서 유지보수성은 변경 시 발생하는 위험과 밀접하게 관련되어 있다.

#### `전역 상태(global state)`
> 취약성의 근원이다, 해당 단어에서 의미하는 `전역(global)`은 우리고 고려한 범위를 벗어난것을 의미한다. 메서드로 생각하면
> 내부 변수가 전역변수를 참조하는것이다. <br>
> `상태(state)`는 실행되는동안 변경될 수 있는 모든 것을 말한다.
> 모든 변수뿐만아니라, 데이터, 파일, 하드웨어 자체도 포함된다.
> 
> 전역상태를 생각하는데 도움이 되는 트릭은 중괄호를 찾는것이다, 중괄호 외부의 모든 것이 중괄호 내부의 모든 거셍 대해 전역상태로 간주된다.

---

### 리팩터링의 세가지 핵심
1. 의도를 전달함으로써 가독성 향상
2. 불변속성의 범위제한을 통한 유지보수성 향상
3. 범위 밖의 코드에 영향을 주지 않고 1항과 2항을 수행.


---

### 상속보다는 컴포지션 사용

상속보다 컴포지션을 사용할 경우 다음과 같은 장점들이 있다.

1. 유연성과 확장성. 
2. 다중 상속의 복잡성 회피 
3. 강력한 모듈화
4. 의존성 감소


컴포지션의 사용 예 
```java
// 엔진 클래스
class Engine {
    void start() {
        System.out.println("Engine started");
    }

    void stop() {
        System.out.println("Engine stopped");
    }
}

// 자동차 클래스
class Car {
    private Engine engine;  // Engine 객체를 내부에 포함

    Car() {
        engine = new Engine();
    }

    void start() {
        System.out.println("Car is starting the engine...");
        engine.start();
    }

    void stop() {
        System.out.println("Car is stopping the engine...");
        engine.stop();
    }
}

// 메인 클래스
public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();
        myCar.start();
        myCar.stop();
    }
}
```

---

### 수정이 아닌 추카로 코드를 변경

컴포지션 방식의 가장 좋은 장점은 추가로 변경이 가능하다는 점이다.

추가가 가능하다는 것은  기존 기능에 영향을 주지 않고 기능을 추가하거나 변경하는것을 의미한다.(SOLID의 OCP에 해당하는 얘기)


#### 🧐 안정성 
추가에 의한 변경 방식을 따르면 기존 코드를 항상 보존할수 있다.. 새코드가 실패할 경우 이전 기능으로
대체하는 기능을 구현하는것은 쉽다. 이를 통해 기존 기능에 새로운 오류가 발생하지 않게할 수 있다.


---

#### 리팩터링과 일상 업무
 - 리팩터링을 일상 업무에 포함시켜 기술 부채가 쌓이지 않도록 해야한다.
 - 리팩터링을 연습하면 코드에 대한 독특한 관점을 얻을 수 있고, 이로 인해 더 나은 해결책을 찾을 수 있다.

---

## 3. 긴 코드 조각내기 