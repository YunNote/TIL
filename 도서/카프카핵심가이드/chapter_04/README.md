# 카프카 컨슈머 : 카프카에서 데이터 읽기

---

카프카에서 데이터를 읽는 애플리케이션들은 토픽을 구독하고 토픽들로부터 메시지를 받기 위해
컨슈머를 사용한다.

---

## 카프카 컨슈머 : 개념

### 컨슈머와 컨슈머 그룹 

프로듀서가 컨슈머가 처리하는 작업속도보다 빠르게 메시지를 보내게 된다면 계속해서 메시지들은 뒤로 밀리게 된다. 따라서 데이터를
읽어오는작업을 확장할 수 있어야 한다. 

동일한 컨슈머가 동일한 토픽에 메시지를 쓰듯이, 여러 개의 컨슈머가 같은 토픽으로부터 데이터를 분할해서 읽어 올 수 있어야 한다.

카프카 컨슈모는 보통 컨슈머 그룹으로 동작하는데 해당 그룹에 속한 컨슈머딜이 동일한 토픽을 구독할 경우 
각각의 컨슈머는 해당 토픽에서 서로 다른 파티션의 메시지를 받는다.


컨슈머 그룹에 컨슈머를 추가하는 것은 토픽에서 읽어오는 데이터 양을 확장시켜주는 효과가 있다.

다만 주의해야할 점은 토픽에 설정된 파티션 수 이상으로 컨슈머를 투입하는 것은 아무 의미가 없다. (만약 넘는다면 노는 컨슈머가 생긴다)

만약 새로운 컨슈머 그룹 G1과 G2가 있다면 동일한 토픽에 대해서 다른 컨슈머 그룹과 동시에 모든 메시지를 받을 수 있다.

---


### 컨슈머 그룹과 파티션 리밸런스

컨슈머 그룹에 속한 컨슈머들은 자신들이 구독하는 토픽의 파티션들엗 대한 소유권을 공유하며, 새로운 컨슈마가 추가된다면 다른 컨슈머가
읽고있던 파티션으로부터 메시지를 읽기 시작한다.

또한 컨슈머 그룹에 속한 컨슈머에서 문제가 발생한경우도 마찬가지이다. 컨슈머에 할당된 파티션을 다른 커슈머에게 할당해주는 작업을
`리밸런스`라고 한다. 

`리밸런스`는 컨슈머 그룹에 높은 가용성과 규모 가변성을 제공하는 기능이기에 매우 중요하다, 하지만 작업이
수행되고 있는 와중이라면 달갑지 않은 기능이다.

`리밸런스`에는 파티션 할당 전략이 2가지가 있다. 

<br>

#### 조급한 리밸런스

조급한 리밸런스가 실행되는 중에는 모든 컨슈머가 읽기 작업을 멈추고 자신에게 할당된 모든 파티션에 대한 소유권을 포기한 뒤
컨슈머 그룹에 다시 참여(rejoin)하여 완전히 새로운 파티션 할당을 전달받는다.

해당 방식은 짧은 시간동안 컨슈머의 작업을 멈추가 한다. 작업 중단시간은 컨슈머 그룹의 크기와 여러 설정 매개변수에 영향을 받는다.

#### 협력적 리밸런스 

협력적 리밸런스는 한 컨슈머에게 할당되어 있던 파티션만을 다른 컨슈머에게 재할당 한다.

재할당 되지 않은 파티션에서 레코드를 읽어서 처리하던 컨슈머들은 작업에 방해받지 않고 하던 일을 계속할 수 있다.

협력적 리밸런스는 2가지 단계로 리밸런싱을 한다.

1. 먼저 컨슈머 그룹이 컨슈머들에게 파티션 중 일부가 재할당될 것이라고 통보한다 그러면 컨슈머들은 해당 파티션에서 데이터를 읽는 작업을 멈추고 해당 파티션에 대한 소유권을 포기한다.
2. 컨슈머 그룹 리더가 포기된 파티션들을 새로 할당한다.

위 방식으로 진행되며 안정적으로 파티션이 재할당될 때가지 몇번 반복될 수 있다. 해당 박식은 조급한 리밸런스 방식에서 발생하는 전체 작업이 중단되는 사태는 발생하지 않는다.


컨슈머는 해당 컨슈머 그룹의 그룹코디네이터 역할일 지정받은 카프카 브로커에 하트비트를 전송함으로써 할당된 파티션에 대한
소유권을 유지한다.

하트비트는 백그라운드 스레드에 의해 일정한 간격을 두고 전송된되는한 연결이 유지되는 것으로 간주한다.

만약 컨슈머가 일정 시간 이상 하트비트를 전송하지 않는다면 타임아웃이 발생하면서 그룹 코디네이터는 해당 컨슈머가 죽었다고
간주하고 리밸런스를 실행한다. ( 컨슈머에 이상이 발생하였을 경우도 동일하다 )

하지만 깔끔하가 닫아줄 경우 컨슈머는 그룹 코디네이터에게 그룹을 나간다고 통지하게 되고 그러면 그룹 코디네이터는
즉시 리밸런스를 실행함으로써 처리가 정지되는 시간을 줄인다.

> 버전 3.1 이후의 컨슈머 리밸런스
> 
> 버전 2.4 이후로 조급한 리밸런스가 기본값이 었지만 3.1 이후로서는 협력적 리밸런스가 기본값이 되었다.<br>
> 만약 조급한 리밸런스를 사용중이라면 조만간 삭제될 예정이기 때문에 미리 업데이트를 하는것이 좋다.

---

### 정적 그룹 멤버십

정적 그룹 멤버십이란 group.instance.id값을 잡아줌으로써 해당 컨슈머가 컨슈머그룹의 정적인 멤버가 되도록 설정해준다.

해당 옵션을 설정하면 평소와 같이 해당 그룹이 사용하고 있는 파티션 할당 전략에 따라 파티션이 할당된다.<br>
하지만 해당 컨슈머가 꺼질 경우 자동으로 그룹을 떠나지는 않는다. 세션 타임아웃 기간동안 다시 조인하게 되면 멤버십이 그대로 유지되기 때문에
리밸런스가 발생할 필요 없이 할당받았던 그대로 재할당 받는다.

> 그룹 코디네이터가 그룹 내 각 멤버에 대한 파티션 할당을 캐시해 두고 있기 때문에 정적 멤버가 다시 조인하더라도 리밸런스를 발생시키지 않는다.

주의 사항
1. 같은 grouop.instance.id 값을 갖는 두개의 컨슈마 같은 그룹에 조인한다면 두번째 컨슈머에서는 이미 존재한다는 에러가 발생한다.
2. 캐시를 유지해줘 다시 연결되었을때 리밸런싱을 한다는 장점이 있찌만 반대로 생각하면 그동안 다른 컨슈머에서 해당 파티션에 대해서 메시지를 읽어오지 않는다는 의미가 된다

2번의 주의사항을 위해 `session.timeout.ms`설정이 잇으며 리밸런스를 작동시키지않을만큼 충분하면서.. 일정 시간동안
작동이 멈출 경우 자동으로 파티션이 재할당 되어 오랫동안 파티션 처리가 멈추는 상황을 막을수 있을만큼의 시간을 설정해야한다.

---

## 카프카 컨슈머 생성하기

카프카 레코드를 읽어오기위해서는 KafkaConsumer인스턴스를 생성해야한다. 앞에 나왔단 KafkaProducer와 매우 비슷하다.

필수값을 이전에 KafkaProducer와 동일하다.

 프로듀서와 조금 다른점이 있다면 앞내용에 나왔던것처럼 group.id속성 을 통하여 컨슈머 그룹을 정의해줄 수 있다.
 
---

## 토픽 구독하기.

> Consumer를 생성하고 난 후 해야할 일은 토픽을 구독해야 한다. subscribe()메서드는 토픽목록을
> 매개변수로 받기 때문에 간단하게 사용할 수 있다. 
> 
> 패턴을 통해서도 토픽을 구독할 수 있다.


### 폴링 루프 

컨슈머 API의 핵심을 서버에 추가 데이터가 들어왔는지 폴링하는 단순한 루프이다.
( 코드 첨부 X P.92 )

무한 루프를 돌며 poll 메소드를 일정시간마다 호출하여 데이터를 읽어들여  메시지에 대한 처리를 진행한다.

poll 메서드를 호출하면컨슈머는 GroupCoordinator를 찾아 컨슈머 그룹에 참가하고, 파티션을 할당받는다.

리밸런스 역시 연관된 콜백들과 함께 처리된다. 컨슈머 혹은 콜백에서 예외가 발생하면 거의 모든것들은 poll()에서 발생한다.

poll() 이 max.poll.interval.ms에 지정된 시간 이상으로 호출되지 않는다면 컨슈머는 죽은것으로판정되어
컨슈머그룹에서 퇴출당한다. 따라서 폴링 루프안에서 오랜 시간동안 블록되는 작업은 피하는것이 좋다.

---

### 스레드 안전성

하나의 스레드에서 동일한 그룹 내에 여러개의 컨슈머를 생성할 수 없으며, 같은 컨슈머를 다수의 스레드가 안전하게
사용할 수도 없다. 

`하나의 스레드당 하나의 컨슈머가 원칙이다` 하나의 애플리케이션에서 동일한 그룹에 속하는 여러 개의 컨슈머를
운용하고 싶다면 스레드를 여러 개 띄워서 각각에 컨슈머를 둬야 한다. 컨슈머 로직을 감싼다음 ExecutorService를 사용하여 시작하면 좋다.

---

## 컨슈머 설정하기

> 기본 속성 외에도 컨슈머에 사용 가능한 속성들에 대해서 설명한다.

### fetch.min.bytes