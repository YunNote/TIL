# 6장 카프카 내부 메커니즘

카프카의 내부를 알면 트러블슈팅하거나 실행되는 방식을 이해하는데 도움이 된다.

- 카프카 컨트롤러
- 카프카에서 복제(레플리케이션)의 동작방식
- 프로듀서와 컨슈머의 요청을 처리하는 방식
- 카프카가 저장을 처리하는 방식

---

## 클러스터 멤버십

카프카는 클러스터의 멤버인 브로커들의 목록을 유지하기위해 아파치 주키퍼를 사용한다.

각각의 브로커는 브로커 설정파일에 정의되어있거나 자동으로 생성된 고유한 식별자를 가진다.<br>
브로커 프로세스는 시작될 때마다 주키퍼에 Ephemeral 노드 형태로 ID를 등록한다, 컨트롤러를 포함한
카프카 브로커들과 몇몇 툴들은 브로커가 등록되는 주키퍼의 /brokers/ids 경로를 구독함으로써 브로커가 추가되거나 제거될 때 마다
알림을 받는다. 

ID는 중복될 수 없기때문에 동일한 ID를 가진 브로커가 시작한다면 에러가 발생한다. 

브로커와 주키퍼가 간의 연결이 끊어진다면 브로커가 시작될 때 생성한 노드는 자동으로 주키퍼에서 삭제된다. 또한 해당 브로커 경로를
구독한 컴포넌트들은 해당 브로커가 내려갔다는것을 알 수 있다.

---

## 컨트롤러 



1. 제일 먼저 시작되는 브로커가 주키퍼 /controller 노드를 생성함으로써 컨트롤러가 된다.
2. 이후 브로커 역시 생성하려고 요청하지만 이미 컨트롤러가 있다면 더이생 생성하지 않고 와치를 통해 변경이 생길 시 알림을 받음.
3. 만약 컨트롤러가 멈추가너 연결이 끊어진다면 알림을 통해 다른 브로커들이 컨트롤러가 되기 위해주키퍼에 요청.
4. 이후 2번과 같은 작업을 반복.

> 선출될때마다 주키퍼의 조건적 증가 연산에 의해 증가된 에포크(세대 의미)를 전달받으며 해다 에포크 값보다 낮은 가진 컨트롤러부터 메시지를
> 받을 경우 해당 값들을 무시한다.


새로운 컨트롤러가 선출되었다는 것을 알지 못한 채 브로커에 메시지를 보낼 수 있다. 이러한 건트롤러를좀비라고부른다.
컨트롤러가 전송하는 메시지에 컨트롤러 에포크를 포함하면 브로커는 예전 컨트롤러가보내온 메시지를 무시할 수 있다. 이는 좀비를 방지하는방법이기도한 것이다.

브로커가 컨트롤러가 된다면 주키퍼로부터 최신 레플리카 상태맵을 읽어 온다. 해당 작업은 비동기API를 사용하여 진행되며
지연을 줄이기 위해 요청을 여러단계로 나눠 주키퍼로 보낸다. 그럼에도 파티션수가 매우 많다면 적재 작업이 몇초씩 걸리기도 한다.


브로커가 클러스터를 나간것을 알게 된다면 해당 브로커에 속한 파티션에 대해 새로운 브로커를 할당해주며, 
컨트롤러는 새로운 리더가 필요한 모든 파티션을 순회하며 새로운 리더가 될 브로커를 결정해준다. 

새로운 상태를 주키퍼에 쓴뒤 새로 리더가 할당된 파티션의 레플리카를 포함하는 모든 브로커에 LeaderAndISR 새로운
리더와 팔로워 정보를 포함한다. 

요약하면 컨트롤러는 브로커가 클러스터에 추가되거나 제거될때 파티션과 레플리카 중에서 리더를 선출할 책임을 갖고. 
컨트롤러는 서로 자기가 컨트롤러라고 생각하는 스플릿브레인 현상을 방지하기 위해 에포크 번호를 사용한다.

> 스플릿 브레인 - 분산시스템에서 많이 발생하며 심각한 문제중 하나이다. 말그대로 누구나 마스터 노드가 되려는 경향
> 
> 