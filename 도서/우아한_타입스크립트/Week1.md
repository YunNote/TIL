
## 타입이란 

`undefined`, `null`, `Boolean`, `String`, `Symbol`, `Numeric`, `Object`

7가지 타입을 정의한다

---

### 집합으로서의 타입 

수학의 집합과 유사, 타입은 값이 가질 수 있는 유효한 범위의 집합을 말한다.

어떠한 값이 T 타입이라면 컴파일러는 사전에 어떤일을 할수 있고 없는지를 알 수 있다. 따라서 유효한 값의
범위를 제한하여 런타임에서 발생할 수 있는 유효하지 않은 값에 대한 에러를 방지한다.

---

### 정적 타입과 동적 타입

정적 타입은 모든 변수의 타입이 컴파일타임에 결정된다. 번거롭기는 하지만 컴파일 탕미에
타입 에러를 발견할 수 있어 안정성을 보장할 수 있다.

동적 타입은 런타임에 결정되기 때문에 타입을 정의해줄 필요가 없다. 다만 프로그램을 실행할 때 타입 에러가
발견되기 때문에 개발과정에서 에러 없이 작성할 수 있지만 언제 에러가 발생할지 알 수 없다.

---

### 강타입과 약타입.

강타입 특징을 가진 언어에서는 서로 다른ㄹ 타입을 갖는 값끼리 연산을 시도한다면 컴파일러
또는 인터프리터에서 에러가 발생한다. 

약타입의 특징은 서로 다른 타입을 갖는 값끼리 연산할때는 컴파일러 또는 인터프리터가 내부적으로
판단해서 특정 값의 타입을 변환하여 연산을 수행항 후 값을 도출한다.

---

## 타입스크립트의 타입 시스템

### 타입 애너테이션 방식

> 변수나 상수 혹은 함수의 인자와 반환값에 타입을 명시적으로 선언해서 어떠한 타입 값이 저장될 것인지를 컴파일러에게
> 직접 알려주는 문법이다.
> 
> const color : string = "blue"

### 구조적 타이핑

> 타입을 사용하는 여러 언어에서 값이나 객체는 하나의 구체적인 타입을 가지고 있다. 타입은 이름으로 구분되고
> 컴파일 타임 이후에도 남아있다. 이것을 구체화한 타입시스템이라고 부르기도 한다 .
> 
> 보통 다른 클래스끼리 명확한 상속관계나 공통으로 가지고 있는 인터페이스가 없다면 서로 호환되지 않지만
> 타입스크립트에서는 조금 다르다.
> 
> 이름으로 타입을 구분하는 명목적인 타입언어와 달리 타입스크립트는 구조로 타입을 구분한다. 이것을 구조적 타이핑이라고 한다.

```typescript
interface A {
  value: number;
}

interface B {
  value: number;
}

let aType: A = { value : 500 };
let bType: B = { value : 1500 };

aType = bType; // OK
bType = aType; // OK
```

---

### 구조적 서브타이핑 

타입스크립트는 집합으로 이해할 수 있다. 따라서 타입은 단지 집합에 포함되는 값이고 특정 값은 많은
집합에 포함될 수 있다. 

```typescript
type stringOrNumber = string | number;
```

이러한 방식을 구조적 서브타이핑이라고 한다. 또한 이름이 다른 객체라도 가진속성이 동일하다면 서로 호환이 가능한
동일한 타입으로 여긴다

```typescript
interface Name {
  name: string
}

interface Person {
  name: string,
  age: number;
}

let name: Name;
let person:Person = {name: "YunNote", age:32};

name = person; // OK
```

name필드를 가지고 있기 때문에 Person타입의 값을 name변수에 넣어줄 수 있다.

이러한 타입흔 매개변수에도 적용된다.

---

### 점진적 타입 확인

타입 스크립트는 필요에 따라 선언 생략을 허용한다. 타입을 지정한 변수와 표현식은 정적으로 타입을 검사하지만
타입 선언이 생략되면 동적으로 검사를 수행하게 된다. 타입 선언을 생략하면 암시적
타입 변환이 일어난다.

함수의 파라미터에 타입을 선언하지않는다면 any로 추론된다. 타입스크립트는 컴파일타임에
모든 타입을 알고 있을때 최상의 결과를 보여준다.

---

### 배민에서는 Enum을 어떻게 활용할까 

- 유니온보다는 enum을 선호한다. 유니온은 어떤 타입을 가졌는지 전부 기억해야하고 변경이 필요하면 사용되는 모든곳을 모두 찾아서 바꿔야할 수 있다.
- 다른경우 enum을 지양하기도 한다. 성능에 영향을 줄 수 있따는 내용은 본거 같다는 내용이 있음.

---

### 트리쉐이킹
> 자바스크립트, 타입스크립트에서 사용하지 않는 코드를 삭제하는 방식, 나무를 흔들면 죽은나뭇잎이 떨어지는 모습을
> 보고 따온 이름, 웹팩, 롤업같은 모듈 번들러를 사용하면 사용하지 않는코드는 자동 삭제된다. CommonJS는 지원하지 않지만
> ES6이후 특정 모듈만 임포트하면 해당 모듈을 사용하지 않는 코드는 자동으로 삭제되어 작은 크기의 번들링 파일 생성 가능.

---

### 타입을 확인하는 방법

instanceof, typeof를 사용할 수 있따.

 - 값 타입은 자바스크립트 런타임의 typeof 연산자가 되어 해당 값의 타입을 반환한다
 - 타입에서 사용되는 typeof는 값을 읽고 타입스크립트 타입을 반환한다.(P.63)

---

### any 타입 
> any타입은 타입스크립트로 달성하고자 하는 정적 타이핑을 무색하게 하기 때문에 지양하는것이 좋다. 따라서
> any를 회피하는것은 좋은 습관으로 관주된다. 정적타입 관점에서 보면 매우 타당하며, tsconfig.json파일에
> noImplicitAny 옵션을 활성화하면 명시되지 않은 변수의 암묵적인 any에 대해서 경고를 발생시킨다.

다만 any타입을 어쩔수 없이 사용해야할 때가 있는데 대표적으로 3가지 가 있다.

1. 개발 단계에서 임시로 값을 지정해야할 때
    > 매우 복잡한 구성요소이거나 추후 값이 변경될 가능성이 있거나 아직 타입이 확정되지 않은 경우 해당 값을 any로 지정하여
    > 경고 없이 개발을 진행할 수 있다. 그러나 너무 남발하면 타입 안정성을 저해하기 때문에 추후 반드시 변경해줘야 한다.

2. 어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을때
    > API요청 및 응답 처리, 콜백함수전달, 타입이 정제되지 않아 파악이 힘들 라이브러리 등을 사용할 때

3. 값을 예측할 수 없을 때 암묵적으로 사용 
   > 외부 라이브러리나 웹 API의 요청에 따라 다양한 값을 반환하는 API가 존재할 수 있다. fetch의 .json()이 any로 반환하게 되어있다.
