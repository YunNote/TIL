## 😊 EntityManagerFactory, EntityManager

---

`EntityManagerFactory`는 `EntityManager`를 만들어주는 공장같은 일을 한다. 
이러한 `EntityManagerFactory`을 만드는 비용은 크기 때문에 한개만 만들어서 애플리케이션에서 
공유하도록 설계가 되어있다고 한다.


`EntityManager`는 Entity를 저장하고, 수정, 삭제등 엔티티와 관련된 일을 처리하게 도와준다.
이러한 `EntityManager`는 `EntityManagerFactory`를 통해 생성이 된다. `EntityManager`를 만드는 비용은
크지 않다. 

주의해야할 점은 `EntityManagerFactory`는 여러 스레드가 동시에 접근해도 안전하기 때문에 다른 스레드에서
공유하여 사용해도 되지만 `EntityManager`는 스레드가 동시에 접근하면 동시성 문제가 발생하기 때문에
스레드 간에 공유를 하지 않는것이 좋다.

> EntityManager는 Database의 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.<br> 
> EntityManager는 Transaction을 시작할 때 커넥션을 사용한다.
> 

---

## ⭐ 영속성 컨텍스트 (Persistence Context)

>개인적으로 JPA 에서 제일 중요한 용어 및 개념이라고 생각합니다

영속성 컨텍스트를 해석하면 `Entity를 영구 저장하는 환경`이라는 의미를 가집니다.

Entity Manager를 통하여 Entity를 저장 or 수정을 하면 해당 Entity Manager 는 영속성 컨텍스트에 Entity를 보관하고 관리하게 됩니다.

```java
// 단순히 저장하는것이 아닌, EntityManager를 통해 Member Entity를 영속성 컨텍스트에 저장한다는 의미.
em.persist(member);
```

---

## ⭐ 영속성 컨텍스트의 특징

1. 영속 상태를 가지기 위해서는 반드시 고유 식별값이 있어야 한다. 식별자 값이 없다면 예외가 발생한다.
2. JPA는 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 등록된 엔티티를 데이터베이스에 반영하게 되는데 이것을 `flush`라고 부른다.
3. 영속성 컨텍스트가 엔티티를 관리함으로써 얻을수 있는 장점
    
    - 1차 캐시
    - 동일성 보장
    - 트랜잭션 지원하는 쓰기 지연
    - 변경 감지
    - 지연 로딩
---

## 😊 Entity의 생명 주기 

JPA의 Entity에는 총 4가지의 상태가 있습니다. `비영속`, `영속`, `준영속`, `삭제`입니다.<br>
하나씩 정리해보면 다음과 같습니다.

#### `비영속`  - 단어 그대로 영속성 컨텍스트와 전혀 상관이 없는 상태를 의미한다.
#### `영속` - 영속성 컨텍스트에 저장된 상태를 의미한다.
#### `준영속` - 영속성 컨텍스트에 저장되어 있다가 분리된 상태 
#### `삭제` - 삭제된 상태 

---

### ⭐ 비영속 
> 비영속 상태는 엔티티 객체를 생성하였지만, 순수 객체 상태이며 아직 저장하지 않은 상태를 의미한다.
> 따라서 영속성 컨텍스트나 데이터베이스와는 상관이 없다.


### ⭐ 영속
> 엔티티 매니저를 통해서 연속성 컨텍스트에 저장된 상태를 의미한다. 이 말은 즉 영속성 컨텍스트에 의해 관리된다는 의미로 보면 된다.

### ⭐ 준영속 
> 엔티티가 영속성 컨텍스트를 통해 관리되다가 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.
> 영속 상태의 엔티티를 준영속 상태의 엔티티로 변경하기 위해서는 detach() 를 호출하면 된다. close(), clear()를 호출하여 
> 영속성 컨텍스트를 초기화하여도 준영속 상태가 된다.


### ⭐ 삭제
> 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한 상태.