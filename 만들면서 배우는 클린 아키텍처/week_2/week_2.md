#### 해당 정리 내용은 `만들면서 배우는 클린아키텍처`도서를 읽고 정리한 내용입니다.

## 4. 유스케이스 구현하기

일반적으로 유스케이스는 다음과 같은 단계를 따른다.

1. 입력을 받는다
2. 비즈니스 규칙을 검증한다.
3. 모델 상태를 조작한다
4. 출력을 반환한다.

---

### 입력 유효성 검증
해당 도서에서는 `입력 유효성 검증`은 유스케이스 클래스의 책임이 아니라고 이야기가 나왔다.

하지만 해당 유스케이스를 호출하는 어댑터가 유스케이스에 입력을 전달하기 전에 `입력 유효성 검증`을 하면 어떨까.<br>
과연 유스케이스에서 필요한 파라미터들을 모두 검증했다고 믿을 수 있을까?

이러한 내용에대한 문제는 해당 유스케이스를 하나 이상의 어댑터에서 호출할때 발생한다.

그렇다면 모든 어댑터에서 `유효성 검증`을 해야한다. 이러한 과정에서 실수 할 수 있고, 추가로 어댑터에서
`유효성 검사`를 하지 않아 검증이 되지 않은 상태로 유스케이스로도 넘어갈 수 있다.

애플리 케이션 계층에서 `입력 유효성 검증`을 해야하는 이유는, 해당 계층에서 하지 않을 경우 애플리케이션 코어의 바깥쪽으로부터
유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있기 때문이다.

#### ✔️ 생성자 내에서 `입력 유효성` 검사

```java
class Sample {
 
    private final Money money;
    
    public Sample(final Money money) {
        requireNonNull(money);
        requireGreaterThan(money, 0);
        
        this.money = money;
    }
}
```

위의 예제는 생성자메서드에서 `입력 유효성`검사를 하는 방식에 대한 예제이다.<br>
해당 생성자 메서드는 유효성 검사를 통과하지 못하게 된다면 객체를 생성할 때 에외를 던져서 객체 생성을 막으면된다.

이러한 귀찮은 작업들을 대신해 줄 수 있는 도구는 자바의( [Bean Validation API](https://beanvalidation.org/2.0/) 가 이러한 작업을 위한 표준 라이브러리다.

```java

class Sample {
    
    @NonNull
    private final Money money;

    public Sample(final Money money) {
        requireGreaterThan(money, 0);
        this.money = money;
    }
}
```

`@NonNull`, `@NonEmpty`, `@NonBlank`등과 같은 애노테이션을 사용하여 작업 가능, 추가로 해당 애노테이션들이 특정한
유효성 검증 규칙을 표현하기가 어렵다면 직접 메서드를 구현할 수 있다. 

---

#### ✔️ 생성자 내에서 `입력 유효성` 검사

위의 Sample 클래스를 통하여 객체를 생성하고자 한다면 유효하지 않은 상태의 객체를 만드는 것은 불가능하다.

해당 예제는 Builder 패턴을 사용하였을 경우의 내용이다.
만약 파라미터를 여러개 받는 클래스에서 생성자를 private 으로 만들고 빌도패턴을 사용시 다음과 같이 객체를 만들수 있다.
```java
new Sample.builder()
        .money(new Money(1L))
        ...
        .build();
```
해당 코드는 `유효성 검증 로직`은 생성자에 그대로 둬서 빌더가 유효하지 않은 상태의 객체를 생성하지 못하도록 막을 수 있다.

그렇다면 해당 코드는 완벽할까?? 만약 해당 클래스에 프로퍼티가 추가되었는데 바쁜일때문에 깜빡하고 빌더를 호출하는 코드에 새로운 
프로퍼티를 추가하는 것을 잊어버렸다고 가정한다.

그렇다면 해당 객체를 만들려는 시도에 대해서 경고를 해주지 못한다. 따라서 빌더 뒤에 숨기는 대신
생성자를 직접 사용하였다면 새로운 필드를 추가하거나 프로퍼티를 삭제할 때마다 컴파일 에러를 따라 나머지 코드에
변경사항을 반영할 수 있었을것이다.

---


#### ✔️ 유스케이스마다 다른 입력 모델 

각 유스케이스 전용 입력 모델은 유스케이스를 훨씬 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한 부수효과가 발생하지 않게 한다.

물론 각각의 입력 모델(request)를 만드는데는 비용이 들지만 추후에 매핑 전략에 대해서 나온다.

---

###  비즈니스 규칙 검증하기

`입력 유효성 검증`은 유스케이스 로직의 일부가 아닌 반면, `비즈니스 규칙 검증`은 유스케이스 로직의 일부이다.

`입력 유효성 검증`과 `비즈니스 규칙 검증`은 다음과 같은 차이가 있다.
<br><br>
#### 입력 유효성 검증

- 실제 도메인 모델에 접근할 필요 없음.
- @NotNull과 같은 선언적 구현 가능
- 구문상의 유효성을 검증하는것.
<br><br>

#### 비즈니스 검증

- 실제 도메인 모델에 접근해야함
- @NotNull과 같은 선언적 구현 불가능
- 유스케이스의 맥락 속에서 의미적은 유효성 검증.


> `example`<br>
> "출금 계좌는 초과 출금되어서는 안된다"<br>
> "송금되는 금액은 0보다 커야한다"

다음 두개의 글을 보면 `출금 계좌는 초과 출금되어서는 안된다.` 해당 내용은 도메인 모델에 직접 접근해야 하기 때문에 비즈니스 규칙이다.
반면 `송금되는 금액은 0보다 커야한다`라는 규칙은 도메인 모델에 직접 접근하지 않고도 검증될 수 있기 때문에 
`입력 유효성 검증`을 통해 구현할 수 있다.

---

#### ✔️ 비즈니스 규칙 검증 구현 방법

<b> 1. 가장 좋은 방법은 비즈니스 규칙을 해당 도메인 엔티티 안에 넣는것이다.</b>b>

>이러한 방법을 사용하게 된다면 해당 규칙을 지켜야하는 비즈니스 로직 옆에 규칙이 위치하기 때문에 위치를 정하는 것도 쉽고 추론하기도 쉽다.


<b> 2. 유스케이스 코드에서 도메인 엔티티를 사용하기 전에 한다.</b>

> Entity가 아닌 service (애플리케이션 계층)에 사용해도 된다. 

---

###  풍부한 도메인 모델 vs 빈약한 도메인 모델

DDD를 공부하다 보면 `풍부판 도메인 모델`을 구현할 것인지 `빈약한 도메인 모델`을 구현할 것인가에 대한 얘기가 많이 나오지만 해당책에서는
어느하나에 치우치지 않았다.

#### ✔️ 풍부한 도메인 모델
> 풍부한 도메인 모델에서는 애플리케이션의 코어에 있는 엔티티에서 가능한 많은 도메인 로직이 구현된다.
> 엔티티들의 상태를 변경하는 메서드, 비즈니스 규칙에 맞는 유효한 변경만을 허용한다.


#### ✔️ 빈약한 도메인 모델
> 엔티티 자체가 굉장히 얇다. 일반적으로는 상태를 표현하는 필드와 이값을 읽고 바꾸기 위한 메서드만 포함하고 어떤 도메인 로직도 가지고 있지 않다.
> 이말은 즉 도메인 로직이 유스케이스 클래스에 구현돼 있다는 것이다.

2개의 도메인 모델 표현방식에 대해 알아보앗지만 각자의 필요에 맞는 스타일을 자유롭게 택해서 사용하면 된다.

---

###  유스케이스마다 다른 출력 모델

유스케이스가 할 일을 다했다면 무엇을 반환해야할까??

입력 모델과 비슷하게 출력모델도 가능하다면 유스케이스에 맞게 구체적일수록 좋다.
출력은 호출자에게 꼭 필요한 데이터만 들고 있어야 한다.

유스케이스 간에 같은 출력 모델을 공유하여 사용하게 된다면 해당 유스케이들도 강하게 결합된다.

만약 하나의 출력모델을 다양한 유스케이스가 공유하여 사용할 경우 유스케이스에 새로운 필드가 필요하게 된다면
해당 출력모델과 관련없는 유스케이스들도 이 필드를 처리해야한다.

당장은 개발하기 편하겠지만, 단일 책임 원칙을 적용하고 모델을 분리해서 유지하는 것은 유스케이스의 결합을 제거하는 데 도움이 된다.

---

## 5. 웹 어댑터 구현하기

### 의존성 역전 (P.54 참고)

웹 어댑터는 인커밍 어댑터이다. <br>
외부로부터 요청을 받아 애플리케이션 코어를 호출하고 무슨 일을 해야할지 알려준다.<br>
제어의 흐름은 웹 어댑터에 있는 컨트롤러에서 애플리케이션 계층에 있는 서비스로 흐른다.

의존성 역전의 적용을 위해 `웹 어댑터`가 `유스케이스를 직접 호출 할 수 있다.

웹 어댑터와 유스케이스 사이에 또 다른 간접 계층을 넣는 이유는 애플리케이션 코어가 외부 세계와 통신할 수 있는 곳에 대한 명세가 포트이기 때문이다.

---

### 웹 어댑터의 책임

웹 어댑터는 일반적으로 다음과 같은 일을 한다.
1. HTTP 요청을 자바 객체로 매핑 
2. 권한 검사
3. 입력 유효성 검즘
4. 입력을 유스케이스의 입력 모델로 매핑
5. 유스케이스 호출
6. 유스케이스의 출력을 HTTP로 매핑
7. HTTP 응답을 반환


웹 어댑터에 있는 `입력 유효성 검증`은 유스케이스의 `입력 모델과`는 구조나 의미가 완전 다를 수 있으므로 또 다른 유효성 검증을 수행해야 한다.

유스케이스 입력 모델에서 했던 유효성 검증을 똑같이 웹 어댑터에서도 구현해야 하는것은 아니다. 다만 웹어댑터의 입력 모델을 유스케이스의 입력 모델로 변환할 수 있다는 것을 검증해야 한다.
이 변환을 방해하는 모든 것이 유효성 검증 에러이다.

---

### 컨트롤러 나누기 

어댑터는 하나의 컨트롤러에 몰아 넣어도 되지만, 그럴 필요 없이 웹 어댑터는 하나 이상의 클래스로 구성되어도 된다.

> !! 다만 클래스들이 같은 소속이라는 것을 표현하기 위해 같은 패키지 수준에 놓아야 한다.

하나의 컨트롤레어 모두 모여 있으면 괜찮아 보이지만, 시간이 지나면서 컨트롤러에 200줄만 늘어나도
당장 50줄을 파악하는 것에 비해 난이도가 높아지며, 아무리 메서드로 깔끔하게 분리하였어도 쉽지 않은 일이며,

테스트 코드도 컨트롤러에 코드가 많다면 해당하는 테스트 코드도 많을 것이다. 또한 테스트코드는 더 추상적이라서 프로덕션 코드에 비해 파악하기 어려울 때가 많다.

따라서 특정 프로덕션 코드에 해당하는 테스트 코드를 찾기 쉽게 만들어야 하는데, 클래스가 작을수록 더 찾기가 쉽다.

추가로 이렇게 나누는 스타일의 또 다른 장점은 서로 다른 개발자들이 코드를 짜더라도 병합 충돌이 일어나지 않을 것이다.

#### ✔️ 패키지의 분리

가급 적이면 별도의 패키지 안에 별도의 컨트롤러를 만드는 방식을 선호한다.
또한 가급적 메서드와 클래스명은 유스케이스를 최대한 반영해서 지어야 한다.

#### ✔️ 네이밍 

예를 들어 Create,Update, Delete 만으로 충분히 의미를 드러낼수도 있겠지만 그렇지 못한 경우도 많기 때문에
해당 단어들을 사용하기 전에 한 번 더 숙고해보면 좋겠다.

---

## 6. 영속성 어댑터 구현하기

P.64의 그림 6.1은 앞에 나온 어댑터 처럼 애플리케이션 계층 서비스에서 영속성 기능을 사용하기 위한 포트 인터페이스를 호출한다.
해당 이미지의 포트는 실제로 영속성 작업을 수행하고 데이터베이스와 통신할 책임을 가진 영속성 어댑터 클래스에 의해 구현된다.

영속성 어댑터는 헥사고날 아키텍처에서 `아웃고잉`어댑터이다. 애플리케이션에 의해 호출될뿐, 애플리케이션을 호출하지 않기 때문이다.

이러한 영속성 어댑터를 의존성 역전을 이용하여 작성하게 되면, 영속성 코드를 리팩터링 하더라도 코어 코드를 변경하는 결과로 이어지지 않는다.


### 영속성 어댑터의 책임

1. 입력을 받는다
2. 입력을 데이터베이스 포맷으로 매핑한다
3. 입력을 데이터베이스로 보낸다
4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다
5. 출력을 반환한다.

### 포트 인터페이스 나누기

P.66의 그림 6.2처럼 하나의 연산을 하나의 리포지토리 인터페이스에 넣어 두는게 일반적인 방법이다.

이렇게 구현하는 방ㅂ식에는 문제가 있다. 데이터베이스 연산에 의존하는 각 서비스는 인터페이스에서 단 하나의 메서드만 사용하더라도 넓은 포트 인터페이스에 의존성을갖게 된다.
따라서 코드에 불필요한 의존성이 생긴다.

> 클라이언트가 오로지 자신이 필요로 하는 메서드만 알면 되도록 넓은 인터페이스를 특화된 인터페이스로 분리해야 한다.

---

### 영속성 어댑터 나누기

도메인 코드는 영속성 포트에 의해 정의된 명세를 어떤 클래스가 충족시키는지에 관심없다. 모든 포트가 구현돼 있기만 한다면 
영속성 계층에서 하고 싶은 어떤작업이든 해도 된다.

`애그리거트당 하나의 영속성 어댑터` 접근 방식 또한 나중에 여러개의 바운디드 컨텍스트의 영속성 요구사항을 분리하기 위한 좋은 토대가 된다.


---


### 데이터베이스 트랜잭션은 어떻게 처리 해야 하나?

자바와 스프링에서 제공하는 `@Transactional` 애너테이션을 활용하여 감싸고 유지하면 된다.